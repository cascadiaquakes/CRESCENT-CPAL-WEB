<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/view3d.css">
    <title>CPAL 3D Viewer</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Cesium.js"></script>
    <script src="/static/config/project.js"></script>
    <script>
        // Unique flag only for this page
        window.SKIP_CESIUM = { skip: false };
    </script>
    <!-- Load config.js synchronously -->
    <script>
        console.log("Starting the script ");
        let branch = "{{ branch }}";
        let configFilePath = `/static/config/${branch === "main" ? "" : branch + "/"}config.js`;

        if (branch !== "main") {
            // console.warn("[WARN] Loading configuration from branch:", branch, configFilePath);
        }

        let xhr = new XMLHttpRequest();
        xhr.open('GET', configFilePath, false); // synchronous
        xhr.onload = function () {
            if (xhr.status === 200) {
                let script = document.createElement('script');
                script.text = xhr.responseText;
                document.head.appendChild(script);
            } else {
                console.error("Failed to load config.js");
            }
        };
        xhr.send(null);
    </script>

    <style>
        @import url(https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Widgets/widgets.css);

        #cesiumContainer {
            width: 100%;
            height: 60vh;
            display: block;
        }

        .button {
            background-color: #004F59;
            width: 100%;
            border-radius: 15px;
        }

        #northArrow {
            position: absolute;
            top: 70px;
            right: 300px;
            width: 50px;
            height: 50px;
            background-image: url('/static/images/north_white.png');
            background-size: contain;
            pointer-events: none;
            z-index: 10000;
        }

        #legend {
            position: absolute;
            bottom: 17%;
            left: 10px;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div style="position: relative; margin-top:0;height:50px;font-family: Arial, sans-serif;">
        <div style="display: flex; align-items: center; gap: 10px;">
            <button id="centeredViewButton1" style="background-color: #004F59; border-radius: 5px;color: white;">View
                Home</button>
            <button style="background-color: #004F59; border-radius: 5px;color: white;" onclick="clearHighlight()">Clear
                Highlights</button>
            <button style="background-color: #004F59; border-radius: 5px;color: white;" onclick="resetMarkers()">Group
                Markers</button>

            <label for="spreadAdjustmentSlider" style="font-size:smaller;">Spread Offset:</label>
            <input type="range" id="spreadAdjustmentSlider" min="1" max="500" step="1" value="250" style="width: 25%;">
            <span id="spreadAdjustmentValue" style="font-size:smaller;">50</span>
        </div>

        <!-- Site Dropdown Menu -->
        <div>
            <select id="siteSelectionDropdown"
                style="background-color: #004F59; margin-left: 10px; padding: 5px; border-radius: 5px;color:white;">
                <option value="">Select a site...</option>
            </select>
        </div>
    </div>

    <div id="northArrow"></div>
    <div id="cesiumContainer"></div>

    <div id="legend">
        <h3 style="margin: 0; padding-bottom: 5px;">Legend:</h3>
    </div>
    <div id="logoContainer">
        <img src="" alt="Logo" id="logo-image">
    </div>
    <div id="fileTable" style="display:none;"><b>Selected Dataset(s):</b>
        <div id="datasetContainer" style="margin-top: 5pt;"></div>
        <div class="sliderContainer" style="font-weight: bold; display:none;"></div>
        <div style="font-weight: bold; display:none;">
            <label class="sliderLabel" for="gridOpacitySlider">Grid Opacity:</label>
            <input type="range" id="gridOpacitySlider" min="0" max="1" step="0.1" value="0.3">
            <span id="gridOpacityValue">0.3</span>
        </div>
        <button id="centeredViewButton" style="margin-top: 10pt;">View Home</button>

        <!-- Marker Spread Controls (hidden in iframe UI, but kept wired to logic) -->
        <div id="spreadControls" style="margin-top: 20px;">
            <div style="margin-bottom: 10px;">
                <label for="spreadRadiusSlider" style="font-weight: bold;">Marker Selection Radius (meters):</label>
                <input type="range" id="spreadRadiusSlider" min="1000" max="100000" step="1000" value="35000"
                    style="width: 100%;">
                <span id="spreadRadiusValue">35000</span> m
            </div>
            <div style="margin-bottom: 10px;">
                <label for="spreadCircleRadiusSlider" style="font-weight: bold;">Marker Spread Distance:</label>
                <input type="range" id="spreadCircleRadiusSlider" min="0" max="300" step="1" value="50"
                    style="width: 100%;">
                <span id="spreadCircleRadiusValue">350</span> m
            </div>
        </div>
    </div>

    <script>
        let legendDone = false;
        let lastHighlightedMarker = null;          // Highlighted marker from map click
        let lastHighlightedBarMarkers = [];        // Highlighted markers from chart click

        // Detect whether inside iframe
        let hasParent = (window.top !== window.self);

        function createFormattedCoordinate(lat, lon, label) {
            return {
                lon: lon,
                lat: lat,
                label: `${label} ${lon.toFixed(1)}\u00B0,${lat.toFixed(1)}\u00B0`
            };
        }

        // Logo injection
        document.addEventListener('DOMContentLoaded', function () {
            const logoImage = document.getElementById('logo-image');
            logoImage.src = logoFile;
        });

        let columnDescriptionsByProxy = {};

        async function loadColumnDescriptions() {
            const descriptionPromises = Object.keys(COLUMNS_DESCRIPTION).map(async (proxyKey) => {
                const descriptionUrl = COLUMNS_DESCRIPTION[proxyKey];
                try {
                    const response = await fetch(descriptionUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch column descriptions for ${proxyKey}`);
                    }
                    const jsonData = await response.json();
                    columnDescriptionsByProxy[proxyKey] = jsonData;
                } catch (error) {
                    console.error(`Error loading column descriptions for ${proxyKey}:`, error);
                    columnDescriptionsByProxy[proxyKey] = {};
                }
            });

            await Promise.all(descriptionPromises);
        }

        loadColumnDescriptions().then(() => {
            console.log("Column descriptions loaded:", columnDescriptionsByProxy);
        });

        document.addEventListener('DOMContentLoaded', function () {
            const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE);

            console.log("Setting the viewer");

            const viewer = new Cesium.Viewer('cesiumContainer', {
                imageryProvider: arcGisImagery,
                depthPlaneEllipsoidOffset: 10000,
                nearToFarRatio: 1e6,
                farToNearRatio: 1e-6,
                sceneMode: Cesium.SceneMode.SCENE3D,
                scene3DOnly: true,
                skyAtmosphere: false,
                enableCollisionDetection: false,
                navigationInstructionsInitiallyVisible: true,
                baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery),
                globe: new Cesium.Globe(Cesium.Ellipsoid.WGS84, {
                    minimumZoomDistance: 0.0
                })
            });

            viewer.scene.backgroundColor = Cesium.Color.BLACK;
            viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
            viewer.scene.screenSpaceCameraController.enableCollisionDetection = false;
            viewer.scene.screenSpaceCameraController.minimumZoomDistance = 1;
            viewer.scene.screenSpaceCameraController.maximumZoomDistance = 10000000;

            const canvas = viewer.canvas;
            const originalPositions = new Map();
            const spreadLines = [];
            const originalMarkers = [];
            let markersSpread = false;
            let ranks = {
                "Site-Averaged Evidence Rank (0 - 3)": 0,
                "Age Rank (0 - 5)": 0,
                "Evidence Rank (0 - 3)": 0
            };

            // Messages from parent: filter markers + selection rectangle
            window.addEventListener("message", function (event) {
                if (event.data.action === "updateMarkers") {
                    console.log("Received updateMarkers message:", event.data);

                    const { latMin, latMax, lonMin, lonMax, minEvidenceRank, minAgeRank, minSiteEvidenceRank } = event.data;

                    ranks["Site-Averaged Evidence Rank (0 - 3)"] = minSiteEvidenceRank;
                    ranks["Age Rank (0 - 5)"] = minAgeRank;
                    ranks["Evidence Rank (0 - 3)"] = minEvidenceRank;

                    console.log("Ranks:", ranks);
                    DisplayMarkerByRank(latMin, latMax, lonMin, lonMax);
                }
            });

            window.addEventListener("message", function (event) {
                let selectionOverlay;

                if (!event.data.action) return;

                const latMin = event.data.latMin;
                const latMax = event.data.latMax;
                const lonMin = event.data.lonMin;
                const lonMax = event.data.lonMax;

                console.log(`Received message: ${event.data.action}`);

                if (event.data.action === "updateMapBounds") {
                    function filterMarkersByBounds(latMin, latMax, lonMin, lonMax) {
                        viewer.entities.values.forEach(entity => {
                            if (entity.position) {
                                const cartographic = Cesium.Cartographic.fromCartesian(entity.position._value);
                                const lat = Cesium.Math.toDegrees(cartographic.latitude);
                                const lon = Cesium.Math.toDegrees(cartographic.longitude);

                                entity.show = (lat >= latMin && lat <= latMax && lon >= lonMin && lon <= lonMax);
                            }
                        });
                    }
                    filterMarkersByBounds(latMin, latMax, lonMin, lonMax);
                }

                if (event.data.action === "updateSelectionOverlay") {
                    const { latMin, latMax, lonMin, lonMax } = event.data;

                    console.log(`Updating selection overlay for lat/lon bounds: Latitude: ${latMin}° to ${latMax}°, Longitude: ${lonMin}° to ${lonMax}°`);

                    const existingOverlay = viewer.entities.getById("selectionOverlay");
                    if (existingOverlay) {
                        console.log("Removing existing overlay...");
                        viewer.entities.remove(existingOverlay);
                    }

                    selectionOverlay = viewer.entities.add({
                        id: "selectionOverlay",
                        rectangle: {
                            coordinates: Cesium.Rectangle.fromDegrees(lonMin, latMin, lonMax, latMax),
                            material: new Cesium.Color(0.5, 0.5, 0.5, 0.5),
                            outline: true,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 2
                        }
                    });

                    console.log("New selection overlay added.");
                }
            });

            const siteDropdown = document.getElementById('siteSelectionDropdown');
            const siteLocations = new Map();

            function populateDropdown() {
                siteDropdown.innerHTML = "";

                const defaultOption = document.createElement("option");
                defaultOption.value = "home";
                defaultOption.textContent = "Select a site...";
                siteDropdown.appendChild(defaultOption);

                const siteArray = Array.from(siteLocations.entries())
                    .filter(([_, coords]) => coords.evidenceType !== "Fragile Geologic Features");

                siteArray.sort((a, b) => b[1].lat - a[1].lat);

                siteArray.forEach(([siteName, coords]) => {
                    const option = document.createElement("option");
                    const latLabel = coords.lat.toFixed(2);
                    option.value = siteName;
                    option.textContent = `${siteName} (lat: ${latLabel}°)`;
                    siteDropdown.appendChild(option);
                });

                siteDropdown.addEventListener("change", function () {
                    if (this.value === "home") {
                        centeredView();
                    }
                });
            }

            function clearSiteInfo() {
                const infoContainer = document.getElementById("datasetContainer");
                if (infoContainer) {
                    infoContainer.innerHTML = "";
                }
            }

            function zoomToSite(siteName) {
                if (!siteLocations.has(siteName)) return;

                const { lon, lat } = siteLocations.get(siteName);
                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(lon, lat, 10000),
                    orientation: {
                        heading: 0.0,
                        pitch: Cesium.Math.toRadians(-90.0),
                        roll: 0.0
                    }
                });
            }

            function simulateMarkerClick(marker) {
                if (!marker || !marker.position) return;

                const position = marker.position.getValue(Cesium.JulianDate.now());
                const screenSpacePosition = Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, position);

                if (screenSpacePosition) {
                    const simulatedEvent = {
                        position: new Cesium.Cartesian2(screenSpacePosition.x, screenSpacePosition.y)
                    };

                    const clickHandler = viewer.screenSpaceEventHandler.getInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);

                    if (clickHandler) {
                        clickHandler(simulatedEvent);
                    } else {
                        console.warn("Click handler for LEFT_CLICK is not defined.");
                    }
                }
            }

            siteDropdown.addEventListener("change", function () {
                const selectedSite = siteDropdown.value;
                if (selectedSite) {
                    clearHighlight();
                    resetMarkers();
                    zoomToSite(selectedSite);
                    highlightMarkerBySiteName([selectedSite], null);
                }
            });

            PROXIES.forEach((proxyKey) => {
                console.log("Loading GeoJSON and extracting unique site names from ", proxyKey);
                const geojsonUrl = GEOJSON_URLS[proxyKey];

                Cesium.GeoJsonDataSource.load(geojsonUrl, { clampToGround: true }).then((dataSource) => {
                    dataSource.entities.values.forEach(entity => {
                        if (entity.properties && entity.position) {
                            const siteName = entity.properties["Site"]?.getValue() || "Unknown Site";
                            const evidenceType = entity.properties["Evidence Type"]?.getValue() || "Unknown Evidence Type";
                            const siteKey = [siteName, evidenceType].join(": ");
                            const position = entity.position.getValue(Cesium.JulianDate.now());
                            const cartographic = Cesium.Cartographic.fromCartesian(position);
                            const lat = Cesium.Math.toDegrees(cartographic.latitude);
                            const lon = Cesium.Math.toDegrees(cartographic.longitude);

                            if (!siteLocations.has(siteKey)) {
                                siteLocations.set(siteKey, { lat, lon, siteName, evidenceType });
                            }
                        }
                    });
                    populateDropdown();
                }).catch(console.error);
            });

            let spreadRadius = parseInt(document.getElementById("spreadRadiusSlider").value, 10);
            let spreadCircleRadius = parseInt(document.getElementById("spreadCircleRadiusSlider").value, 10);

            window.addEventListener("message", function (event) {
                if (event.data.action === "highlightMarker") {
                    const siteNames = event.data.sites;
                    const evidenceType = event.data.evidence;
                    highlightMarkerBySiteName(siteNames, evidenceType);

                    const firstKey = siteNames[0];
                    const location = Array.from(siteLocations.entries()).find(([key]) => key.startsWith(firstKey));
                    if (location) {
                        const { lon, lat } = location[1];
                        viewer.camera.flyTo({
                            destination: Cesium.Cartesian3.fromDegrees(lon, lat, 10000),
                            orientation: {
                                heading: 0.0,
                                pitch: Cesium.Math.toRadians(-90.0),
                                roll: 0.0
                            }
                        });
                    }

                    const firstMarker = lastHighlightedBarMarkers[0];
                    simulateMarkerClick(firstMarker);
                }
            }, false);

            function DisplayMarkerByRank(latMin, latMax, lonMin, lonMax) {
                viewer.entities.values.forEach(marker => {
                    if (!Array.isArray(marker.customProperties) || marker.customProperties.length === 0) {
                        marker.show = false;
                        return;
                    }

                    let contactName = marker.customProperties[0]["Contact Name"] || "Unknown";
                    let passesAllRanks = true;

                    const enableLogging = false;

                    if (enableLogging) console.log(`Checking Marker: ${contactName}`);

                    for (let rankKey in ranks) {
                        let rankPassed = false;

                        if (enableLogging) console.log(`   Checking Rank: "${rankKey}" (Required: ${ranks[rankKey]})`);

                        for (let i = 0; i < marker.customProperties.length; i++) {
                            let item = marker.customProperties[i];
                            let value = item[rankKey];

                            if (value !== undefined) {
                                if (enableLogging) console.log(`      ${rankKey} in customProperties[${i}]: ${value}`);

                                if (value >= ranks[rankKey]) {
                                    rankPassed = true;
                                    if (enableLogging) console.log(`      Pass`);
                                    break;
                                }
                            } else if (enableLogging) {
                                console.log(`      Missing value for "${rankKey}" in customProperties[${i}]`);
                            }
                        }

                        if (!rankPassed) {
                            passesAllRanks = false;
                            if (enableLogging) console.log(`   Marker ${contactName} FAILED on rank: "${rankKey}"`);
                            break;
                        }
                    }

                    const cartographic = Cesium.Cartographic.fromCartesian(marker.position._value);
                    const lat = Cesium.Math.toDegrees(cartographic.latitude);
                    const lon = Cesium.Math.toDegrees(cartographic.longitude);
                    const inArea = (lat >= latMin && lat <= latMax && lon >= lonMin && lon <= lonMax);
                    marker.show = passesAllRanks && inArea;
                });
            }

            function highlightMarkerBySiteName(siteNames, evidenceType) {
                if (!siteNames || siteNames.length === 0) return;

                let foundMarkers = [];

                viewer.entities.values.forEach(marker => {
                    if (marker.customProperties) {
                        const site = marker.customProperties[0]?.Site || "Unknown";
                        const evidence = marker.customProperties[0]?.["Evidence Type"] || "Unknown";

                        if (siteNames.includes(site) && (evidenceType == null || evidenceType == evidence)) {
                            foundMarkers.push(marker);
                        }
                    }
                });

                if (foundMarkers.length > 0) {
                    if (lastHighlightedBarMarkers.length > 0) {
                        lastHighlightedBarMarkers.forEach(marker => {
                            marker.billboard.scale = 1.0;
                            marker.billboard.color = Cesium.Color.WHITE;
                        });
                        lastHighlightedBarMarkers = [];
                    }

                    foundMarkers.forEach(marker => {
                        marker.billboard.scale = 2.0;
                        marker.billboard.color = Cesium.Color.BLACK;
                        marker.billboard.disableDepthTestDistance = Number.POSITIVE_INFINITY;
                    });

                    lastHighlightedBarMarkers = foundMarkers;
                } else {
                    console.warn("No markers found for sites:", siteNames, "with evidence types:", evidenceType);
                }
            }

            document.getElementById("spreadRadiusSlider").addEventListener("input", (event) => {
                spreadRadius = parseInt(event.target.value, 10);
                document.getElementById("spreadRadiusValue").textContent = spreadRadius;
            });

            document.getElementById("spreadCircleRadiusSlider").addEventListener("input", (event) => {
                spreadCircleRadius = parseInt(event.target.value, 10);
                document.getElementById("spreadCircleRadiusValue").textContent = spreadCircleRadius;
            });

            canvas.addEventListener("contextmenu", (event) => {
                event.preventDefault();

                const clickPosition = viewer.camera.pickEllipsoid(
                    new Cesium.Cartesian2(event.clientX, event.clientY),
                    viewer.scene.globe.ellipsoid
                );

                if (Cesium.defined(clickPosition)) {
                    const closeMarkers = getMarkersWithinRadius(clickPosition, spreadRadius);
                    if (closeMarkers.length > 0) {
                        if (!markersSpread) {
                            spreadMarkers(closeMarkers);
                            markersSpread = true;
                        } else {
                            resetMarkers();
                            markersSpread = false;
                        }
                    }
                } else {
                    console.warn("Click position is not on the globe.");
                }
            });

            function getMarkersWithinRadius(centerPosition, radius) {
                const closeMarkers = [];
                viewer.entities.values.forEach((entity) => {
                    if (Cesium.defined(entity.position)) {
                        const entityPosition = entity.position.getValue(Cesium.JulianDate.now());
                        const distance = Cesium.Cartesian3.distance(centerPosition, entityPosition);

                        if (distance <= radius) {
                            closeMarkers.push(entity);
                        }
                    }
                });
                return closeMarkers;
            }

            function spreadMarkers(pickedObjects) {
                pickedObjects.forEach((pickedObject, index) => {
                    if (Cesium.defined(pickedObject.position)) {
                        const originalPosition = pickedObject.position.getValue(Cesium.JulianDate.now());
                        if (!originalPositions.has(pickedObject.id)) {
                            originalPositions.set(pickedObject.id, originalPosition);
                        }

                        const angle = (2 * Math.PI * index) / pickedObjects.length;
                        const cartographic = Cesium.Cartographic.fromCartesian(originalPosition);
                        const radiusInDegrees = spreadCircleRadius / (111320 * Math.cos(cartographic.latitude));
                        const offsetLat = cartographic.latitude + radiusInDegrees * Math.sin(angle);
                        const offsetLon = cartographic.longitude + radiusInDegrees * Math.cos(angle);
                        const newPosition = Cesium.Cartesian3.fromRadians(offsetLon, offsetLat, cartographic.height);

                        pickedObject.position = newPosition;

                        const lineEntity = viewer.entities.add({
                            polyline: {
                                positions: [newPosition, originalPosition],
                                width: 2,
                                material: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.WHITE),
                                clampToGround: false,
                                depthFailMaterial: new Cesium.PolylineOutlineMaterialProperty({
                                    color: Cesium.Color.WHITE,
                                    outlineWidth: 1,
                                    outlineColor: Cesium.Color.BLACK
                                }),
                                disableDepthTestDistance: Number.POSITIVE_INFINITY
                            }
                        });

                        viewer.scene.globe.depthTestAgainstTerrain = false;
                        spreadLines.push(lineEntity);
                    }
                });
            }

            const spreadAdjustmentSlider = document.getElementById("spreadAdjustmentSlider");
            const spreadAdjustmentValue = document.getElementById("spreadAdjustmentValue");

            spreadAdjustmentSlider.addEventListener("input", (event) => {
                spreadCircleRadius = parseInt(event.target.value, 10);
                spreadAdjustmentValue.textContent = spreadCircleRadius;
            });

            window.resetMarkers = function () {
                viewer.entities.values.forEach((entity) => {
                    if (originalPositions.has(entity.id)) {
                        entity.position = originalPositions.get(entity.id);
                    }
                });

                originalPositions.clear();

                spreadLines.forEach((line) => {
                    viewer.entities.remove(line);
                });
                spreadLines.length = 0;

                viewer.scene.globe.depthTestAgainstTerrain = false;
                console.log("Markers reset and spread lines removed.");
            };

            function getProxyTypeString(proxyKeyLocal) {
                if (!(proxyKeyLocal in PROXY_TYPES)) {
                    return "Invalid proxy: " + proxyKeyLocal;
                }

                const values = Object.values(PROXY_TYPES[proxyKeyLocal]);
                return `${values.join(', ')}`;
            }

            const gridOpacitySlider = document.getElementById('gridOpacitySlider');
            const gridOpacityValue = document.getElementById('gridOpacityValue');
            let gridOpacity = parseFloat(gridOpacitySlider.value);

            gridOpacitySlider.addEventListener('input', function () {
                gridOpacity = parseFloat(gridOpacitySlider.value);
                gridOpacityValue.textContent = gridOpacity;
                addGridLines(MAP_BOUNDS.west, MAP_BOUNDS.east, MAP_BOUNDS.south, MAP_BOUNDS.north);
            });

            function addGridLines(west, east, south, north) {
                const gridLineWidth = 0.5;

                viewer.entities.values.forEach(entity => {
                    if (entity.name === "gridLine") {
                        viewer.entities.remove(entity);
                    }
                });

                for (let lon = Math.ceil(west); lon <= Math.floor(east); lon++) {
                    const lonPositions = Cesium.Cartesian3.fromDegreesArray([
                        lon, south,
                        lon, north
                    ]);
                    viewer.entities.add({
                        name: "gridLine",
                        polyline: {
                            positions: lonPositions,
                            width: gridLineWidth,
                            material: Cesium.Color.LIGHTGRAY.withAlpha(gridOpacity)
                        }
                    });
                }

                for (let lat = Math.ceil(south); lat <= Math.floor(north); lat++) {
                    const latPositions = Cesium.Cartesian3.fromDegreesArray([
                        west, lat,
                        east, lat
                    ]);

                    viewer.entities.add({
                        name: "gridLine",
                        polyline: {
                            positions: latPositions,
                            width: gridLineWidth,
                            material: Cesium.Color.LIGHTGRAY.withAlpha(gridOpacity)
                        }
                    });
                }
            }

            addGridLines(MAP_BOUNDS.west, MAP_BOUNDS.east, MAP_BOUNDS.south, MAP_BOUNDS.north);

            // --- Dataset dropdown in parent ---

            const datasetContainer = window.parent.document.getElementById('datasetContainer');
            const dropdown = document.createElement('select');
            dropdown.id = 'datasetDropdown';
            dropdown.multiple = true;
            dropdown.style.width = '100%';
            datasetContainer.appendChild(dropdown);

            PROXIES.forEach((proxyKey2) => {
                const option = document.createElement('option');
                option.value = proxyKey2;
                option.textContent = getProxyTypeString(proxyKey2);
                option.selected = true;
                dropdown.appendChild(option);
            });

            function updateMarkerVisibility() {
                const selectedOptions = Array.from(dropdown.selectedOptions).map(option => option.value);
                viewer.entities.values.forEach(entity => {
                    if (entity.customDatasetIndex !== undefined && entity.billboard) {
                        if (selectedOptions.includes(entity.customDatasetIndex)) {
                            entity.billboard.color = Cesium.Color.WHITE.withAlpha(1.0);
                        } else {
                            entity.billboard.color = Cesium.Color.WHITE.withAlpha(0.0);
                        }
                    }
                });
            }

            dropdown.addEventListener('change', updateMarkerVisibility);
            updateMarkerVisibility();

            const corners = [
                createFormattedCoordinate(MAP_BOUNDS.north, MAP_BOUNDS.west, 'NW'),
                createFormattedCoordinate(MAP_BOUNDS.north, MAP_BOUNDS.east, 'NE'),
                createFormattedCoordinate(MAP_BOUNDS.south, MAP_BOUNDS.east, 'SE'),
                createFormattedCoordinate(MAP_BOUNDS.south, MAP_BOUNDS.west, 'SW')
            ];

            corners.forEach(corner => {
                viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(corner.lon, corner.lat, 0),
                    point: {
                        pixelSize: 10,
                        color: Cesium.Color.RED
                    },
                    label: {
                        text: corner.label,
                        font: '10pt sans-serif',
                        fillColor: Cesium.Color.RED,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 1,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -20)
                    }
                });
            });

            viewer.scene.globe.frontFaceAlphaByDistance = new Cesium.NearFarScalar(50.0, 0.0, 100.0, 1.0);
            viewer.scene.globe.show = true;
            viewer.scene.fog.enabled = true;
            viewer.scene.globe.showGroundAtmosphere = false;
            viewer.scene.globe.baseColor = Cesium.Color.TRANSPARENT;
            viewer.animation.container.style.visibility = 'hidden';
            viewer.timeline.container.style.visibility = 'hidden';
            viewer.scene.globe.depthTestAgainstTerrain = false;

            const centerLon = (MAP_BOUNDS.west + MAP_BOUNDS.east) / 2;
            const centerLat = (MAP_BOUNDS.south + MAP_BOUNDS.north) / 2;

            window.document.getElementById('centeredViewButton1').addEventListener('click', centeredView);

            function centeredView() {
                const lon = centerLon;
                const lat = centerLat;

                const width = MAP_BOUNDS.east - MAP_BOUNDS.west;
                const height = MAP_BOUNDS.north - MAP_BOUNDS.south;
                const maxDimension = Math.max(width, height);

                const estimatedHeight = maxDimension * 111000 * zoomOutFactor;

                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(lon, lat, estimatedHeight),
                    orientation: {
                        heading: 0.0,
                        pitch: Cesium.Math.toRadians(-90.0),
                        roll: 0.0
                    }
                });
            }

            centeredView();

            function updateNorthArrow() {
                const heading = Cesium.Math.toDegrees(viewer.camera.heading);
                document.getElementById('northArrow').style.transform = `rotate(${-heading}deg)`;
            }

            updateNorthArrow();
            viewer.scene.postRender.addEventListener(updateNorthArrow);

            viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
                e.cancel = true;
                centeredView();
            });

            PROXIES.forEach((proxyKey) => {
                const geojsonUrl = GEOJSON_URLS[proxyKey];
                Cesium.GeoJsonDataSource.load(geojsonUrl, { clampToGround: true }).then((dataSource) => {
                    const uniqueLocationData = {};

                    dataSource.entities.values.forEach(entity => {
                        const properties = {};
                        entity.properties.propertyNames.forEach(propName => {
                            let value = entity.properties[propName].getValue();
                            properties[propName] = value;
                        });

                        entity.columnDefinitions = columnDefinitions;

                        if (Cesium.defined(entity.position)) {
                            const position = entity.position.getValue(Cesium.JulianDate.now());
                            const cartographic = Cesium.Cartographic.fromCartesian(position);
                            const lat = Cesium.Math.toDegrees(cartographic.latitude);
                            const lon = Cesium.Math.toDegrees(cartographic.longitude);
                            const coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;

                            entity.billboard.color = Cesium.Color.WHITE.withAlpha(initialTransparency);

                            if (!uniqueLocationData[coordKey]) {
                                uniqueLocationData[coordKey] = {
                                    lat,
                                    lon,
                                    properties: []
                                };
                            }

                            const propertiesCopy = {};
                            entity.properties.propertyNames.forEach(propName => {
                                let value = entity.properties[propName].getValue();

                                if ((propName.includes("Rank") || propName.includes("Age")) && typeof value === "number") {
                                    value = parseFloat(value.toFixed(2));
                                }

                                propertiesCopy[propName] = value;
                            });

                            uniqueLocationData[coordKey].properties.push(propertiesCopy);
                        }
                    });

                    Object.keys(uniqueLocationData).forEach(coordKey => {
                        const location = uniqueLocationData[coordKey];

                        const contactNames = location.properties.map(property => {
                            const contactName = property["Contact Name"] || "Unknown Contact";
                            return contactName.includes('.') ? contactName.split('.')[0] : contactName;
                        });
                        const uniqueContactNames = new Set(contactNames);
                        const uniqueContactNamesCount = uniqueContactNames.size;

                        const markerSize = baseMarkerSize + uniqueContactNamesCount;

                        let proxy = "Default";
                        let itemIndex = 0;
                        if (Object.keys(PROXY_TYPES[proxyKey]).length === 1 && proxyKey in PROXY_TYPES[proxyKey]) {
                            proxy = PROXY_TYPES[proxyKey][proxyKey];
                        } else {
                            const locationName = location.properties[0]["Evidence Type"];
                            const foundKey = Object.keys(PROXY_TYPES[proxyKey]).find(key => key === locationName);
                            if (foundKey) {
                                proxy = PROXY_TYPES[proxyKey][locationName];
                                itemIndex = Object.keys(PROXY_TYPES[proxyKey]).indexOf(locationName);
                            }
                        }

                        const shapeType = SHAPES[proxy];
                        const colorType = COLORS[proxy];
                        const markerImage = createImage(shapeType, colorType, markerSize);

                        let eyeOffsetValue;
                        if (markerSize < 10) {
                            eyeOffsetValue = eyeOffsetFactor[0] * Math.exp(-markerSize / 5);
                        } else if (markerSize < 20) {
                            eyeOffsetValue = eyeOffsetFactor[1] * Math.log(1 / markerSize);
                        } else {
                            eyeOffsetValue = eyeOffsetFactor[2];
                        }

                        const marker = viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(location.lon, location.lat, 0),
                            billboard: {
                                image: markerImage,
                                width: markerSize,
                                height: markerSize,
                                color: Cesium.Color.WHITE,
                                scale: 1.0,
                                eyeOffset: new Cesium.Cartesian3(0, 0, eyeOffsetValue),
                                disableDepthTestDistance: Number.POSITIVE_INFINITY
                            },
                            customDatasetIndex: proxyKey
                        });

                        marker.customProperties = location.properties;
                    });

                    const uniqueLegendEntries = new Set();

                    function addToLegend(shape, color, description) {
                        const key = `${shape}-${color}-${description}`;
                        if (uniqueLegendEntries.has(key)) return;

                        uniqueLegendEntries.add(key);
                        const legendItem = document.createElement('div');
                        legendItem.style.display = 'flex';
                        legendItem.style.alignItems = 'center';
                        legendItem.style.marginBottom = '5px';

                        const iconCanvas = document.createElement('canvas');
                        iconCanvas.width = iconCanvas.height = 15;
                        const ctx = iconCanvas.getContext('2d');

                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.99;
                        ctx.strokeStyle = "black";
                        ctx.lineWidth = 1;

                        switch (shape) {
                            case 'square': ctx.fillRect(0, 0, 15, 15); ctx.strokeRect(0, 0, 15, 15); break;
                            case 'circle': ctx.beginPath(); ctx.arc(7.5, 7.5, 7.5, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); break;
                            case 'semicircle': ctx.beginPath(); ctx.arc(7.5, 7.5, 7.5, 0, Math.PI); ctx.lineTo(7.5, 7.5); ctx.fill(); ctx.stroke(); break;
                            case 'triangle': ctx.beginPath(); ctx.moveTo(7.5, 0); ctx.lineTo(0, 15); ctx.lineTo(15, 15); ctx.fill(); ctx.stroke(); break;
                            case 'triangle-side': ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 15); ctx.lineTo(15, 7.5); ctx.fill(); ctx.stroke(); break;
                            case 'pentagon':
                                ctx.beginPath();
                                const centerX = 7.5;
                                const centerY = 7.5;
                                const radius = 7.5;
                                const sides = 5;
                                for (let i = 0; i < sides; i++) {
                                    const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                                    const x = centerX + radius * Math.cos(angle);
                                    const y = centerY + radius * Math.sin(angle);
                                    if (i === 0) {
                                        ctx.moveTo(x, y);
                                    } else {
                                        ctx.lineTo(x, y);
                                    }
                                }
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                                break;
                            default: console.error('Invalid shape:', shape); break;
                        }

                        legendItem.appendChild(iconCanvas);
                        const text = document.createElement('span');
                        text.textContent = description;
                        text.style.marginLeft = '10px';
                        legendItem.appendChild(text);

                        document.getElementById('legend').appendChild(legendItem);
                    }

                    if (!legendDone) {
                        legendDone = true;
                        Object.keys(COLORS).forEach(value => {
                            addToLegend(SHAPES[value], COLORS[value], LABELS[value]);
                        });
                    }

                    // Click handler -> popup in parent + highlight marker
                    viewer.screenSpaceEventHandler.setInputAction(async (movement) => {
                        let pickedLon = "N/A";
                        let pickedLat = "N/A";
                        const pickedObject = viewer.scene.pick(movement.position);
                        if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.customProperties) {
                            const propertiesList = pickedObject.id.customProperties;

                            const proxyKey = pickedObject.id.customDatasetIndex;

                            const cartographic = Cesium.Cartographic.fromCartesian(
                                pickedObject.id.position.getValue(Cesium.JulianDate.now())
                            );

                            pickedLon = Cesium.Math.toDegrees(cartographic.longitude).toFixed(4);
                            pickedLat = Cesium.Math.toDegrees(cartographic.latitude).toFixed(4);

                            if (!columnDescriptionsByProxy[proxyKey]) {
                                console.log(`Waiting for column descriptions for proxy ${proxyKey}...`);
                                await loadColumnDescriptions();
                            }

                            const columnDescriptions = columnDescriptionsByProxy[proxyKey] || {};

                            if (lastHighlightedMarker) {
                                lastHighlightedMarker.billboard.scale = 1.0;
                                lastHighlightedMarker.billboard.color = Cesium.Color.WHITE;
                            }

                            pickedObject.id.billboard.scale = 2.0;
                            pickedObject.id.billboard.color = Cesium.Color.BLACK;
                            pickedObject.id.billboard.disableDepthTestDistance = Number.POSITIVE_INFINITY;
                            lastHighlightedMarker = pickedObject.id;

                            var existingPopup = document.getElementById('popupContainer');
                            if (existingPopup) {
                                existingPopup.remove();
                            }

                            const contactNames = propertiesList.map(property => {
                                const contactName = property["Contact Name"] || `Event ${PROXIES.indexOf(proxyKey) + 1}`;
                                return contactName.includes('.') ? contactName.split('.')[0] : contactName;
                            });

                            const normalizedContacts = contactNames.map(name => name.replace(/[a-z?]+$/, ""));
                            const uniqueContactNames = new Set(normalizedContacts);
                            const uniqueContactNamesCount = uniqueContactNames.size;

                            const reorderedKeys = ["Contact Name", ...Object.keys(propertiesList[0]).filter(key => key !== "Contact Name")];

                            function normalizeKey(key) {
                                return key
                                    .toLowerCase()
                                    .replace(/[\s\t\n\r]+/g, '')
                                    .normalize("NFKC");
                            }

                            const normalizedColumnDescriptions = {};
                            const normalizedDisplaySettings = {};

                            Object.keys(columnDescriptions).forEach(key => {
                                const normalizedKey = normalizeKey(key);
                                normalizedColumnDescriptions[normalizedKey] = columnDescriptions[key].description;
                                normalizedDisplaySettings[normalizedKey] = columnDescriptions[key].display || "Yes";
                            });

                            if (!window.parent.hiddenRowIds) {
                                window.parent.hiddenRowIds = [];
                            }

                            let tableHtml = `
<div id="popupContainer" style="width:100%;">
    <div style="display: flex; align-items: center; padding: 5px; background-color: #b3b3b3; position: sticky; top: 0; z-index: 2;">
        <button onclick="
    const popup = document.getElementById('popupContainer');
    if (popup) popup.remove();

    const iframe = document.getElementById('3dIframe');
    if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage({ action: 'resetHighlight' }, '*');
    } else {
        console.error('Iframe or its content is not accessible.');
    }

    const selectedValues = getSelectedDatasetValues();
    plotData(selectedValues);
"
style="background-color: white; color: #333333; border: none; padding: 5px 5px; width:20px; cursor: pointer; font-size: 10px; font-weight: bold; margin-right: 10px;">X</button>

        <span style="color: #333333; font-weight: bold; margin-right: 10px;">
            ${uniqueContactNamesCount} Event${uniqueContactNamesCount > 1 ? 's' : ''} 
            (Longitude: ${pickedLon}, Latitude: ${pickedLat})
        </span>
<label for="toggleHiddenRows" style="margin-left: 10px; font-size: 12px; color: black; display: inline-flex; align-items: center;"> Show&nbsp;Hidden&nbsp;Rows:&nbsp;
    <input type="checkbox" id="toggleHiddenRows" style="margin-right: 4px;" onchange="
        window.parent.hiddenRowIds.forEach(rowId => {
            const row = document.getElementById(rowId);
            if (row) {
                row.style.display = this.checked ? 'table-row' : 'none';
            } else {
                console.warn('Row with ID ' + rowId + ' not found.');
            }
        });
    ">
</label>

    </div>

    <div id="tableContainer" style="overflow:auto; overflow-x: scroll; overflow-y: scroll;">
        <table style="border-collapse: collapse; width: 100%; height:100%;">
            <thead>
                <tr style="background-color: white; position: sticky; top: 0; z-index: 1;">
                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background-color: #b3b3b3; position: sticky; left: 0; z-index: 2;"
                        title="${normalizedColumnDescriptions[normalizeKey('Contact Name')] || 'This column represents Contact Names'}">
                        Contact Name
                    </th>
                    ${contactNames.map(contactName => `
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;"
                            title="${normalizedColumnDescriptions[normalizeKey(contactName)] || contactName}">
                            ${contactName}
                        </th>
                    `).join('')}
                </tr>
            </thead>
            <tbody>
                ${reorderedKeys
                                    .filter(key => key !== "Contact Name")
                                    .map((key, rowIndex) => {
                                        const normalizedKey = normalizeKey(key);
                                        const isHidden = normalizedDisplaySettings[normalizedKey] === "No";
                                        const rowStyle = isHidden ? 'display: none;' : '';
                                        if (isHidden && !window.parent.hiddenRowIds.includes(normalizedKey)) {
                                            window.parent.hiddenRowIds.push(normalizedKey);
                                        }
                                        return `
                        <tr id="${normalizedKey}" style="${rowStyle} background-color: ${rowIndex % 2 === 0 ? '#f1f1f1' : '#e9e9e9'};">
                            <td style="padding: 10px; border-bottom: 1px solid #ddd; color: #333; font-weight: bold; background-color: ${isHidden ? '#d3d3d3' : '#b3b3b3'}; position: sticky; left: 0; z-index: 1;" 
                                title="${normalizedColumnDescriptions[normalizedKey] || key}">
                                ${key}
                            </td>
                            ${propertiesList.map(property => `
                                <td style="padding: 10px; border-bottom: 1px solid #ddd; color: #333;"
                                    title="${normalizedColumnDescriptions[normalizedKey] || key}">
                                    ${property[key] ?? '-'}
                                </td>
                            `).join('')}
                        </tr>`;
                                    }).join('')}
            </tbody>
        </table>
    </div>
</div>`;

                            if (hasParent) {
                                const parentDoc = window.parent.document;
                                const fileTable = parentDoc.getElementById('infobox');

                                if (fileTable) {
                                    fileTable.innerHTML = tableHtml;
                                } else {
                                    console.error("Element with ID 'infobox' not found in parent document.");
                                }
                            } else {
                                document.body.insertAdjacentHTML('beforeend', tableHtml);
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
                }).catch(console.error);
            });

            // Marker symbol generator (used above)
            function createImage(shape, color, size) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.height = size;

                ctx.fillStyle = color;
                ctx.globalAlpha = 0.99;
                ctx.strokeStyle = "black";
                ctx.lineWidth = 1;

                switch (shape) {
                    case 'square': ctx.fillRect(0, 0, size, size); ctx.strokeRect(0, 0, 15, 15); break;
                    case 'circle': ctx.beginPath(); ctx.arc(size / 2, size / 2, size / 2, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); break;
                    case 'semicircle': ctx.beginPath(); ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI); ctx.lineTo(size / 2, size / 2); ctx.fill(); ctx.stroke(); break;
                    case 'triangle': ctx.beginPath(); ctx.moveTo(size / 2, 0); ctx.lineTo(0, size); ctx.lineTo(size, size); ctx.fill(); ctx.stroke(); break;
                    case 'triangle-side': ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, size); ctx.lineTo(size, size / 2); ctx.fill(); ctx.stroke(); break;
                    case 'pentagon':
                        ctx.beginPath();
                        const centerX = size / 2;
                        const centerY = size / 2;
                        const radius = size / 2;
                        const sides = 5;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    default: console.error('Invalid shape:', shape); break;
                }
                return canvas.toDataURL();
            }
        });

        function clearHighlight() {
            if (lastHighlightedMarker) {
                lastHighlightedMarker.billboard.scale = 1.0;
                lastHighlightedMarker.billboard.color = Cesium.Color.WHITE;
                lastHighlightedMarker = null;
            }
            if (lastHighlightedBarMarkers.length > 0) {
                lastHighlightedBarMarkers.forEach(marker => {
                    marker.billboard.scale = 1.0;
                    marker.billboard.color = Cesium.Color.WHITE;
                });
                lastHighlightedBarMarkers = [];
            }
        }

        window.addEventListener("message", function (event) {
            if (event.data.action === "resetHighlight") {
                if (lastHighlightedMarker) {
                    lastHighlightedMarker.billboard.scale = 1.0;
                    lastHighlightedMarker.billboard.color = Cesium.Color.WHITE;
                    lastHighlightedMarker = null;
                }
            }
        });
    </script>
</body>

</html>