<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="/static/css/view3d.css">
    <title>CPAL 3D Viewer</title>
    <script src="https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Cesium.js"></script>
    <script src="/static/config/project.js"></script>
    <script>
        // Unique flag only for this page
        window.SKIP_CESIUM = { skip: false };
    </script>
    <!-- Load config.js synchronously 
                     Synchronous XHR ensures loading order: The browser halts execution until config.js is fetched and executed, 
                    ensuring that all variables are available. If config.js fails to load, a console error message will help diagnose issues.
                    xhrs block the browser’s rendering and prevent the user from interacting with the page until the request completes. However, this
                    pause shoud be brief.-->
    <script>
        console.log("Starting the script ");// + Cesium.Ion.defaultAccessToken);
        // Dynamically create and load the configuration script synchronously before loading other scripts
        let branch = "{{ branch }}";
        let configFilePath = `/static/config/${branch === "main" ? "" : branch + "/"}config.js`;

        if (branch !== "main") {
            // alert("[WARN] Loading configuration from the branch: [" + branch + "]\n" + configFilePath);
        }

        // Load config.js synchronously to ensure its variables are available before other scripts run
        let xhr = new XMLHttpRequest();
        xhr.open('GET', configFilePath, false); // `false` makes the request synchronous
        xhr.onload = function () {
            if (xhr.status === 200) {
                let script = document.createElement('script');
                script.text = xhr.responseText;
                document.head.appendChild(script);

                // Function to capitalize the branch name
                function capitalizeBranchName(branch) {
                    return branch.charAt(0).toUpperCase() + branch.slice(1);
                }
                // Dynamically update the page title if the branch is not "main"
                if (branch !== "main") {
                    let currentTitle = document.title;
                    let domain = window.location.hostname;
                    let capitalizedBranch = capitalizeBranchName(branch);
                    document.title = `[${capitalizedBranch} - ${domain}] ${currentTitle}`;
                    //alert("Page title updated to: " + document.title);

                }
            } else {
                console.error("Failed to load config.js");
            }
        };
        xhr.send(null);
    </script>

    <style>
        @import url(https://cesium.com/downloads/cesiumjs/releases/1.116/Build/Cesium/Widgets/widgets.css);

        #cesiumContainer {
            width: 100%;
            height: 60vh;
            display: block;
        }

        .button {
            background-color: #004F59;
            width: 100%;
            border-radius: 15px;
            /* Adjust the value to make the corners more or less rounded */
        }

        #northArrow {
            position: absolute;
            top: 70px;
            right: 300px;
            width: 50px;
            height: 50px;
            background-image: url('/static/images/north_white.png');
            background-size: contain;
            pointer-events: none;
            z-index: 10000;
        }

        #legend {
            position: absolute;
            bottom: 17%;
            left: 10px;
            background-color: white;
            padding: 10px;
            border-radius: 5px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
        }
    </style>
</head>

<body>
    <div style="position: relative; margin-top:0;height:50px;font-family: Arial, sans-serif;">
        <div style="display: flex; align-items: center; gap: 10px;">
            <button id="centeredViewButton1" style="background-color: #004F59; border-radius: 5px;color: white;">View
                Home</button>
            <button style="background-color: #004F59; border-radius: 5px;color: white;" onclick="clearHighlight()">Clear
                Highlights</button>
            <button style="background-color: #004F59; border-radius: 5px;color: white;" onclick="resetMarkers()">Group
                Markers</button>
            <!-- Marker spread adjustment -->

            <label for="spreadAdjustmentSlider" style="font-size:smaller;">Spread Offset:</label>
            <input type="range" id="spreadAdjustmentSlider" min="1" max="500" step="1" value="250" style="width: 25%;">
            <span id="spreadAdjustmentValue" style="font-size:smaller;">50</span>

        </div>


        <!-- Site Dropdown Menu -->
        <div>
            <select id="siteSelectionDropdown"
                style="background-color: #004F59; margin-left: 10px; padding: 5px; border-radius: 5px;color:white;">
                <option value="">Select a site...</option>
            </select>
        </div>
    </div>


    </div>
    <div id="northArrow"></div>
    <div id="cesiumContainer"></div>

    <div id="legend">
        <h3 style="margin: 0; padding-bottom: 5px;">Legend:</h3>
    </div>
    <div id="logoContainer">
        <img src="" alt="Logo" id="logo-image">
    </div>
    <div id="fileTable" style="display:none;"><b>Selected Dataset(s):</b>
        <div id="datasetContainer" style="margin-top: 5pt;"></div>
        <div class="sliderContainer" style="font-weight: bold; display:none;"></div>
        <div style="font-weight: bold; display:none;"> <!--flex; flex-direction: column; margin-bottom: 10px;">-->
            <label class="sliderLabel" for="gridOpacitySlider">Grid Opacity:</label>
            <input type="range" id="gridOpacitySlider" min="0" max="1" step="0.1" value="0.3">
            <span id="gridOpacityValue">0.3</span>
        </div>
        <button id="centeredViewButton" style="margin-top: 10pt;">View Home</button>

        <!-- New controls for Marker Selection Radius and Spread Distance -->
        <div id="spreadControls" style="margin-top: 20px;">
            <div style="margin-bottom: 10px;">
                <label for="spreadRadiusSlider" style="font-weight: bold;">Marker Selection Radius (meters):</label>
                <input type="range" id="spreadRadiusSlider" min="1000" max="100000" step="1000" value="35000"
                    style="width: 100%;">
                <span id="spreadRadiusValue">35000</span> m
            </div>
            <div style="margin-bottom: 10px;">
                <label for="spreadCircleRadiusSlider" style="font-weight: bold;">Marker Spread Distance:</label>
                <input type="range" id="spreadCircleRadiusSlider" min="0" max="300" step="1" value="50"
                    style="width: 100%;">
                <span id="spreadCircleRadiusValue">350</span> m
            </div>
        </div>
    </div>
    <script>

        let legendDone = false;
        let datasetEntities = {}; // Store entities by dataset URL
        let lastHighlightedMarker = null; // Track the last highlighted marker by clicking on a marker
        let lastHighlightedBarMarkers = []; // Track the last highlighted marker by clicking on a bar segment

        // See if document is inside an iframe. 
        let hasParent = false
        if (window.top !== window.self) { hasParent = true }

        /**
         * Generates a formatted coordinate object for a given latitude, longitude, and label.
         * @param {number} lat - The latitude coordinate.
         * @param {number} lon - The longitude coordinate.
         * @param {string} label - The label for the location.
         * @returns {object} Formatted coordinate object with `lon`, `lat`, and `label` properties.
         */
        function createFormattedCoordinate(lat, lon, label) {
            return {
                lon: lon,
                lat: lat,
                label: `${label} ${lon.toFixed(1)}\u00B0,${lat.toFixed(1)}\u00B0`
            };
        }

        // Load the logo after the HTML is loaded.
        document.addEventListener('DOMContentLoaded', function () {
            // Select the image element by its ID
            const logoImage = document.getElementById('logo-image');

            // Set the src attribute to the desired image URL
            logoImage.src = logoFile;
        });

        let columnDescriptionsByProxy = {}; // Dictionary to store descriptions per proxy

        async function loadColumnDescriptions() {
            const descriptionPromises = Object.keys(COLUMNS_DESCRIPTION).map(async (proxyKey) => {
                const descriptionUrl = COLUMNS_DESCRIPTION[proxyKey]; // URL of the JSON file
                try {
                    const response = await fetch(descriptionUrl);
                    if (!response.ok) {
                        throw new Error(`Failed to fetch column descriptions for ${proxyKey}`);
                    }
                    const jsonData = await response.json();
                    columnDescriptionsByProxy[proxyKey] = jsonData; // Store data
                } catch (error) {
                    console.error(`Error loading column descriptions for ${proxyKey}:`, error);
                    columnDescriptionsByProxy[proxyKey] = {}; // Store an empty dictionary on failure
                }
            });

            await Promise.all(descriptionPromises);
        }

        // Call function before loading GeoJSON data
        loadColumnDescriptions().then(() => {
            console.log("Column descriptions loaded:", columnDescriptionsByProxy);
        });


        document.addEventListener('DOMContentLoaded', function () {
            // Initialize Cesium Viewer
            const arcGisImagery = Cesium.ArcGisMapServerImageryProvider.fromBasemapType(Cesium.ArcGisBaseMapType.SATELLITE);

            console.log("Setting the viewer "); //+ Cesium.Ion.defaultAccessToken + " API Key: " + Cesium.ArcGisMapService.defaultAccessToken);

            const viewer = new Cesium.Viewer('cesiumContainer', {
                imageryProvider: arcGisImagery,
                depthPlaneEllipsoidOffset: 10000,
                nearToFarRatio: 1e6,
                farToNearRatio: 1e-6,
                sceneMode: Cesium.SceneMode.SCENE3D,
                scene3DOnly: true,
                skyAtmosphere: false,
                enableCollisionDetection: false,
                navigationInstructionsInitiallyVisible: true,
                baseLayer: Cesium.ImageryLayer.fromProviderAsync(arcGisImagery),
                //baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3954)),
                globe: new Cesium.Globe(Cesium.Ellipsoid.WGS84, {
                    minimumZoomDistance: 0.0
                })
            });
            viewer.scene.backgroundColor = Cesium.Color.BLACK;
            viewer.screenSpaceEventHandler.removeInputAction(Cesium.ScreenSpaceEventType.LEFT_DOUBLE_CLICK);
            viewer.scene.screenSpaceCameraController.enableCollisionDetection = false; // Prevents terrain locking
            viewer.scene.screenSpaceCameraController.minimumZoomDistance = 1; // Allows closer zoom
            viewer.scene.screenSpaceCameraController.maximumZoomDistance = 10000000; // Ensures far zooming is possible
            const canvas = viewer.canvas;
            const originalPositions = new Map(); // Store original positions of markers
            const spreadLines = []; // Store polylines for visualizing spread markers
            const originalMarkers = []; // Store small markers at original positions
            let markersSpread = false; // Toggle state for spreading/regrouping
            let ranks = {
                "Site-Averaged Evidence Rank (0 - 3)": 0,
                "Age Rank (0 - 5)": 0,
                "Evidence Rank (0 - 3)": 0
            };


            window.addEventListener("message", function (event) {
                if (event.data.action === "updateMarkers") {
                    console.log("Received updateMarkers message:", event.data);

                    const { latMin, latMax, lonMin, lonMax, minEvidenceRank, minAgeRank, minSiteEvidenceRank } = event.data;

                    // Store rank values in the `ranks` object
                    ranks["Site-Averaged Evidence Rank (0 - 3)"] = minSiteEvidenceRank;
                    ranks["Age Rank (0 - 5)"] = minAgeRank;
                    ranks["Evidence Rank (0 - 3)"] = minEvidenceRank;

                    // Properly log the `ranks` object
                    console.log("Ranks:", ranks);
                    DisplayMarkerByRank(latMin, latMax, lonMin, lonMax)

                }
            });




            window.addEventListener("message", function (event) {
                let selectionOverlay;

                if (!event.data.action) return;

                const latMin = event.data.latMin;
                const latMax = event.data.latMax;
                const lonMin = event.data.lonMin;
                const lonMax = event.data.lonMax;

                console.log(`Received message: ${event.data.action}`);

                if (event.data.action === "updateMapBounds") {
                    const { latMin, latMax, lonMin, lonMax, minEvidenceRank, minAgeRank, minSiteEvidenceRank } = event.data;

                    // 🔹 Filter markers based on lat/lon range
                    function filterMarkersByBounds(latMin, latMax, lonMin, lonMax) {
                        viewer.entities.values.forEach(entity => {
                            if (entity.position) {
                                const cartographic = Cesium.Cartographic.fromCartesian(entity.position._value);
                                const lat = Cesium.Math.toDegrees(cartographic.latitude);
                                const lon = Cesium.Math.toDegrees(cartographic.longitude);

                                entity.show = (lat >= latMin && lat <= latMax && lon >= lonMin && lon <= lonMax);
                            }
                        });
                    }

                    filterMarkersByBounds(latMin, latMax, lonMin, lonMax);

                }

                if (event.data.action === "updateSelectionOverlay") {
                    const { latMin, latMax, lonMin, lonMax, minEvidenceRank, minAgeRank, minSiteEvidenceRank } = event.data;

                    console.log(`Updating selection overlay for lat/lon bounds: Latitude: ${latMin}° to ${latMax}°, Longitude: ${lonMin}° to ${lonMax}°`);

                    // 🔹 Convert lat/lon to radians for Cesium
                    const west = Cesium.Math.toRadians(lonMin);
                    const east = Cesium.Math.toRadians(lonMax);
                    const south = Cesium.Math.toRadians(latMin);
                    const north = Cesium.Math.toRadians(latMax);

                    // 🔹 Remove existing overlay if it exists
                    const existingOverlay = viewer.entities.getById("selectionOverlay");
                    if (existingOverlay) {
                        console.log("Removing existing overlay...");
                        viewer.entities.remove(existingOverlay);
                    }

                    // 🔹 Add a new overlay
                    selectionOverlay = viewer.entities.add({
                        id: "selectionOverlay",
                        rectangle: {
                            coordinates: Cesium.Rectangle.fromDegrees(lonMin, latMin, lonMax, latMax),
                            material: new Cesium.Color(0.5, 0.5, 0.5, 0.3), // 🔹 Gray with 30% opacity
                            outline: true,
                            outlineColor: Cesium.Color.WHITE,
                            outlineWidth: 2
                        }
                    });

                    console.log("New selection overlay added.");
                }


            });



            const siteDropdown = document.getElementById('siteSelectionDropdown');
            const siteLocations = new Map(); // Store unique site names and their coordinates

            function populateDropdown() {
                siteDropdown.innerHTML = ""; // Clear existing options

                // Add the default "Select a site..." option
                const defaultOption = document.createElement("option");
                defaultOption.value = "home";
                defaultOption.textContent = "Select a site...";
                siteDropdown.appendChild(defaultOption);

                // Convert siteLocations Map to array of [siteName, {lat, lon, evidenceType}]
                const siteArray = Array.from(siteLocations.entries())
                    .filter(([_, coords]) => coords.evidenceType !== "Fragile Geologic Features"); // ❌ Exclude these

                // Sort by increasing latitude
                siteArray.sort((a, b) => b[1].lat - a[1].lat);

                // Populate dropdown with sorted site names and formatted label
                siteArray.forEach(([siteName, coords]) => {
                    const option = document.createElement("option");
                    const latLabel = coords.lat.toFixed(2);
                    option.value = siteName;
                    option.textContent = `${siteName} (lat: ${latLabel}°)`;
                    siteDropdown.appendChild(option);
                });

                // Add event listener to handle the home view selection
                siteDropdown.addEventListener("change", function () {
                    if (this.value === "home") {
                        centeredView(); // Call centeredView() when "Select a site..." is chosen
                    }
                });
            }

            function clearSiteInfo() {
                const infoContainer = document.getElementById("datasetContainer");
                if (infoContainer) {
                    infoContainer.innerHTML = ""; // Clear existing content
                }
            }


            // Function to zoom to the selected site
            function zoomToSite(siteName) {
                if (!siteLocations.has(siteName)) return;

                const { lon, lat } = siteLocations.get(siteName);
                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(lon, lat, 10000), // Adjust height as needed
                    orientation: {
                        heading: 0.0,
                        pitch: Cesium.Math.toRadians(-90.0), // Looking straight down
                        roll: 0.0
                    }
                });
            }

            function simulateMarkerClick(marker) {
                if (!marker || !marker.position) return;

                // Convert marker position to screen coordinates
                const position = marker.position.getValue(Cesium.JulianDate.now());
                const screenSpacePosition = Cesium.SceneTransforms.wgs84ToWindowCoordinates(viewer.scene, position);

                if (screenSpacePosition) {
                    const simulatedEvent = {
                        position: new Cesium.Cartesian2(screenSpacePosition.x, screenSpacePosition.y)
                    };

                    // Get the current left-click handler
                    const clickHandler = viewer.screenSpaceEventHandler.getInputAction(Cesium.ScreenSpaceEventType.LEFT_CLICK);

                    if (clickHandler) {
                        clickHandler(simulatedEvent);
                    } else {
                        console.warn("Click handler for LEFT_CLICK is not defined.");
                    }
                }
            }


            // Event listener for dropdown selection change
            siteDropdown.addEventListener("change", function () {
                const selectedSite = siteDropdown.value;
                if (selectedSite) {
                    clearHighlight(); // Ensure previous selections are cleared
                    resetMarkers();
                    zoomToSite(selectedSite);

                    // Highlight the new selection
                    highlightMarkerBySiteName([selectedSite], null);

                    // Wait briefly, then trigger the marker click event
                    /*
                    setTimeout(() => {
                        if (lastHighlightedBarMarkers.length > 0) {
                            const firstMarker = lastHighlightedBarMarkers[0];

                            // Ensure previous info is cleared before loading new info
                            clearSiteInfo();

                            // Simulate the marker click
                            simulateMarkerClick(firstMarker);
                        }
                    }, 500);
                    */
                }
            });


            // Load GeoJSON and extract unique site names
            PROXIES.forEach((proxyKey) => {
                console.log("Loading GeoJSON and extracting unique site names from ", proxyKey)
                const geojsonUrl = GEOJSON_URLS[proxyKey];

                Cesium.GeoJsonDataSource.load(geojsonUrl, { clampToGround: true }).then((dataSource) => {
                    dataSource.entities.values.forEach(entity => {
                        if (entity.properties && entity.position) {
                            const siteName = entity.properties["Site"]?.getValue() || "Unknown Site";
                            const evidenceType = entity.properties["Evidence Type"]?.getValue() || "Unknown Evidence Type";
                            const siteKey = [siteName, evidenceType].join(": ")
                            const position = entity.position.getValue(Cesium.JulianDate.now());
                            const cartographic = Cesium.Cartographic.fromCartesian(position);
                            const lat = Cesium.Math.toDegrees(cartographic.latitude);
                            const lon = Cesium.Math.toDegrees(cartographic.longitude);

                            // Store unique sites
                            if (!siteLocations.has(siteKey)) {
                                siteLocations.set(siteKey, { lat, lon, siteName, evidenceType });
                            }
                        }
                    });
                    populateDropdown(); // Populate dropdown after loading data
                }).catch(console.error);
            });


            // Initialize variables directly from slider values
            let spreadRadius = parseInt(document.getElementById("spreadRadiusSlider").value, 10); // Default Marker Selection Radius in meters
            let spreadCircleRadius = parseInt(document.getElementById("spreadCircleRadiusSlider").value, 10); // Default Spread Distance in meters

            window.addEventListener("message", function (event) {

                if (event.data.action === "highlightMarker") {
                    const siteNames = event.data.sites;
                    const evidenceType = event.data.evidence;
                    highlightMarkerBySiteName(siteNames, evidenceType)
                    // Function to zoom to the selected site


                    const { lon, lat, _evidenceType } = siteLocations.get(siteNames[0]);
                    viewer.camera.flyTo({
                        destination: Cesium.Cartesian3.fromDegrees(lon, lat, 10000), // Adjust height as needed
                        orientation: {
                            heading: 0.0,
                            pitch: Cesium.Math.toRadians(-90.0), // Looking straight down
                            roll: 0.0
                        }
                    });
                    const firstMarker = lastHighlightedBarMarkers[0];
                    simulateMarkerClick(firstMarker)
                }
            }, false);

            function DisplayMarkerByRank(latMin, latMax, lonMin, lonMax) {
                viewer.entities.values.forEach(marker => {
                    if (!Array.isArray(marker.customProperties) || marker.customProperties.length === 0) {
                        marker.show = false;
                        return; // No logging if it's not "WB-O-Y"
                    }

                    let contactName = marker.customProperties[0]["Contact Name"] || "Unknown"; // Default to "Unknown" if missing

                    let passesAllRanks = true; // Assume the marker passes all rank conditions

                    // ✅ Only log if Contact Name is "WB-O-Y"
                    let enableLogging = false; //(contactName === "WB-O-Y");

                    if (enableLogging) console.log(`🔍 Checking Marker: ${contactName}`);

                    for (let rankKey in ranks) {
                        let rankPassed = false; // Assume this rank fails initially

                        if (enableLogging) console.log(`   ➡️ Checking Rank: "${rankKey}" (Required: ${ranks[rankKey]})`);

                        for (let i = 0; i < marker.customProperties.length; i++) {
                            let item = marker.customProperties[i];
                            let value = item[rankKey];

                            if (value !== undefined) {
                                if (enableLogging) console.log(`      🔹 Checking ${rankKey} in customProperties[${i}]: ${value}`);

                                if (value >= ranks[rankKey]) {
                                    rankPassed = true; // Rank condition is met
                                    if (enableLogging) console.log(`      ✅ Pass (customProperties[${i}] meets requirement)`);
                                    break; // No need to check further for this rank
                                }
                            } else {
                                if (enableLogging) console.log(`      ⚠️ Missing value for "${rankKey}" in customProperties[${i}]`);
                            }
                        }

                        if (!rankPassed) {
                            passesAllRanks = false;
                            if (enableLogging) console.log(`   ❌ Marker ${contactName} FAILED on rank: "${rankKey}"`);
                            break; // Stop checking further since the marker already failed
                        }
                    }
                    const cartographic = Cesium.Cartographic.fromCartesian(marker.position._value);
                    const lat = Cesium.Math.toDegrees(cartographic.latitude);
                    const lon = Cesium.Math.toDegrees(cartographic.longitude);
                    const inArea = (lat >= latMin && lat <= latMax && lon >= lonMin && lon <= lonMax);
                    marker.show = passesAllRanks && inArea;
                    if (enableLogging) console.log(`🎯 Marker ${contactName} visibility: ${marker.show ? "✅ Shown" : "🚫 Hidden"}`);
                });
            }


            function highlightMarkerBySiteName(siteNames, evidenceType) {
                if (!siteNames || siteNames.length === 0) return;

                let foundMarkers = [];

                viewer.entities.values.forEach(marker => {
                    if (marker.customProperties) {
                        const site = marker.customProperties[0]?.Site || "Unknown";
                        const evidence = marker.customProperties[0]?.["Evidence Type"] || "Unknown";

                        // If evidenceType is null, match only by site name
                        if (siteNames.includes(site) && (evidenceType === null || evidenceType === undefined || evidenceType == evidence)) {
                            foundMarkers.push(marker);
                        }
                    }
                });

                if (foundMarkers.length > 0) {
                    // Reset previous highlighted markers
                    if (lastHighlightedBarMarkers.length > 0) {
                        lastHighlightedBarMarkers.forEach(marker => {
                            marker.billboard.scale = 1.0;
                            marker.billboard.color = Cesium.Color.WHITE;
                        });
                        lastHighlightedBarMarkers = []; // Clear previous highlights
                    }
                    // Highlight new markers
                    foundMarkers.forEach(marker => {
                        marker.billboard.scale = 2.0;
                        marker.billboard.color = Cesium.Color.BLACK; //.withAlpha(0.6);
                        marker.billboard.disableDepthTestDistance = Number.POSITIVE_INFINITY;
                    });

                    // Store highlighted markers
                    lastHighlightedBarMarkers = foundMarkers;
                } else {
                    console.warn("No markers found for sites:", siteNames, "with evidence types:", evidenceType);
                }
            }



            // Add event listeners for sliders to dynamically update the variables
            document.getElementById("spreadRadiusSlider").addEventListener("input", (event) => {
                spreadRadius = parseInt(event.target.value, 10); // Update spread radius
                document.getElementById("spreadRadiusValue").textContent = spreadRadius;
            });

            document.getElementById("spreadCircleRadiusSlider").addEventListener("input", (event) => {
                spreadCircleRadius = parseInt(event.target.value, 10); // Update spread circle radius
                document.getElementById("spreadCircleRadiusValue").textContent = spreadCircleRadius;
            });

            // Right-click handler for spreading or regrouping markers
            canvas.addEventListener("contextmenu", (event) => {
                event.preventDefault(); // Prevent default right-click menu

                // Get the click position on the globe
                const clickPosition = viewer.camera.pickEllipsoid(
                    new Cesium.Cartesian2(event.clientX, event.clientY),
                    viewer.scene.globe.ellipsoid
                );

                if (Cesium.defined(clickPosition)) {
                    const closeMarkers = getMarkersWithinRadius(clickPosition, spreadRadius);
                    if (closeMarkers.length > 0) {
                        if (!markersSpread) {
                            spreadMarkers(closeMarkers); // Spread overlapping markers
                            markersSpread = true; // Mark as spread
                        } else {
                            resetMarkers(); // Regroup markers
                            markersSpread = false; // Mark as grouped
                        }
                    }
                } else {
                    console.warn("Click position is not on the globe.");
                }
            });

            // Function to get markers within a radius from a position
            function getMarkersWithinRadius(centerPosition, radius) {
                const closeMarkers = [];
                viewer.entities.values.forEach((entity) => {
                    if (Cesium.defined(entity.position)) {
                        const entityPosition = entity.position.getValue(Cesium.JulianDate.now());
                        const distance = Cesium.Cartesian3.distance(centerPosition, entityPosition);

                        if (distance <= radius) {
                            closeMarkers.push(entity);
                        }
                    }
                });
                return closeMarkers;
            }

            // Function to spread markers and add visuals
            function spreadMarkers(pickedObjects) {
                pickedObjects.forEach((pickedObject, index) => {
                    if (Cesium.defined(pickedObject.position)) {
                        const originalPosition = pickedObject.position.getValue(Cesium.JulianDate.now());
                        if (!originalPositions.has(pickedObject.id)) {
                            originalPositions.set(pickedObject.id, originalPosition); // Save original position
                        }

                        // Compute spread offsets
                        const angle = (2 * Math.PI * index) / pickedObjects.length;
                        const cartographic = Cesium.Cartographic.fromCartesian(originalPosition);
                        const radiusInDegrees = spreadCircleRadius / (111320 * Math.cos(cartographic.latitude));
                        const offsetLat = cartographic.latitude + radiusInDegrees * Math.sin(angle);
                        const offsetLon = cartographic.longitude + radiusInDegrees * Math.cos(angle);
                        const newPosition = Cesium.Cartesian3.fromRadians(offsetLon, offsetLat, cartographic.height);

                        // Apply new position
                        pickedObject.position = newPosition;

                        // Draw an arrow pointing to the original position
                        const lineEntity = viewer.entities.add({
                            polyline: {
                                positions: [newPosition, originalPosition],
                                width: 2,
                                material: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.WHITE),
                                clampToGround: false, // Prevents clamping issues
                                depthFailMaterial: new Cesium.PolylineOutlineMaterialProperty({ // Ensures visibility when close
                                    color: Cesium.Color.WHITE,
                                    outlineWidth: 1,
                                    outlineColor: Cesium.Color.BLACK
                                }),
                                disableDepthTestDistance: Number.POSITIVE_INFINITY, // Ensures visibility at all zoom levels
                            }
                        });
                        // Reapply depthTestAgainstTerrain to ensure it stays disabled
                        viewer.scene.globe.depthTestAgainstTerrain = false;
                        spreadLines.push(lineEntity); // Store for later removal
                    }
                });
            }

            // Reference the new slider
            const spreadAdjustmentSlider = document.getElementById("spreadAdjustmentSlider");
            const spreadAdjustmentValue = document.getElementById("spreadAdjustmentValue");

            spreadAdjustmentSlider.addEventListener("input", (event) => {
                spreadCircleRadius = parseInt(event.target.value, 10); // Update spread circle radius
                spreadAdjustmentValue.textContent = spreadCircleRadius; // Display updated value

            });

            // Function to adjust the spread dynamically
            function adjustSpreadMarkers() {
                spreadLines.forEach(line => viewer.entities.remove(line)); // Remove old lines
                spreadLines.length = 0; // Clear the stored lines

                originalPositions.forEach((originalPosition, markerId) => {
                    const marker = viewer.entities.getById(markerId);
                    if (marker) {
                        const cartographic = Cesium.Cartographic.fromCartesian(originalPosition);
                        const index = [...originalPositions.keys()].indexOf(markerId);
                        const angle = (2 * Math.PI * index) / originalPositions.size;

                        // Convert spreadCircleRadius (meters) to degrees
                        const radiusInDegrees = spreadCircleRadius / (111320 * Math.cos(cartographic.latitude));
                        const offsetLat = cartographic.latitude + radiusInDegrees * Math.sin(angle);
                        const offsetLon = cartographic.longitude + radiusInDegrees * Math.cos(angle);
                        const newPosition = Cesium.Cartesian3.fromRadians(offsetLon, offsetLat, cartographic.height);

                        // Update marker position
                        marker.position = newPosition;

                        // Redraw the connecting line
                        const lineEntity = viewer.entities.add({
                            polyline: {
                                positions: [newPosition, originalPosition],
                                width: 2,
                                material: new Cesium.PolylineArrowMaterialProperty(Cesium.Color.WHITE),
                                clampToGround: false,
                                disableDepthTestDistance: Number.POSITIVE_INFINITY, // Keeps lines visible at all zoom levels
                            }
                        });
                        spreadLines.push(lineEntity); // Store new line
                    }
                });

                // Reapply depthTestAgainstTerrain to ensure it stays disabled
                viewer.scene.globe.depthTestAgainstTerrain = false;
            }

            window.resetMarkers = function () {
                // Reset all markers to their original positions
                viewer.entities.values.forEach((entity) => {
                    if (originalPositions.has(entity.id)) {
                        entity.position = originalPositions.get(entity.id); // Restore original position
                    }
                });

                // Clear stored positions since we're resetting
                originalPositions.clear();

                // ✅ Remove all spread lines
                spreadLines.forEach((line) => {
                    viewer.entities.remove(line);
                });
                spreadLines.length = 0; // Clear the spreadLines array to avoid leftover references
                // Reapply depthTestAgainstTerrain to ensure it stays disabled
                viewer.scene.globe.depthTestAgainstTerrain = false;
                console.log("Markers reset and spread lines removed.");
            };
            function getProxyTypeString(proxyKeyLocal) {
                if (!proxyKeyLocal in PROXY_TYPES) {
                    return "Invalid proxy: " + proxyKeyLocal;
                }

                const values = Object.values(PROXY_TYPES[proxyKeyLocal]);
                return `${values.join(', ')}`;
            }

            // Add grid lines to the study area.

            // Get the grid slider elements
            const gridOpacitySlider = document.getElementById('gridOpacitySlider');
            const gridOpacityValue = document.getElementById('gridOpacityValue');

            // Update the grid transparency when the slider is moved
            gridOpacitySlider.addEventListener('input', function () {
                gridOpacity = parseFloat(gridOpacitySlider.value); // Update transparency value
                gridOpacityValue.textContent = gridOpacity; // Display the value

                // Redraw the grid lines with the updated transparency
                addGridLines(MAP_BOUNDS.west, MAP_BOUNDS.east, MAP_BOUNDS.south, MAP_BOUNDS.north);
            });

            // Draw grid lines.
            function addGridLines(west, east, south, north) {
                const gridLineWidth = 0.5; // Line width for grid lines

                // Remove any existing grid lines before adding new ones
                viewer.entities.values.forEach(entity => {
                    if (entity.name === "gridLine") {
                        viewer.entities.remove(entity);
                    }
                });

                // Draw vertical lines (longitude lines)
                for (let lon = Math.ceil(west); lon <= Math.floor(east); lon++) {
                    const lonPositions = Cesium.Cartesian3.fromDegreesArray([
                        lon, south,
                        lon, north
                    ]);
                    viewer.entities.add({
                        name: "gridLine",
                        polyline: {
                            positions: lonPositions,
                            width: gridLineWidth,
                            material: Cesium.Color.LIGHTGRAY.withAlpha(gridOpacity)
                        }
                    });
                }

                // Draw horizontal lines (latitude lines)
                for (let lat = Math.ceil(south); lat <= Math.floor(north); lat++) {
                    const latPositions = Cesium.Cartesian3.fromDegreesArray([
                        west, lat,
                        east, lat
                    ]);

                    viewer.entities.add({
                        name: "gridLine",
                        polyline: {
                            positions: latPositions,
                            width: gridLineWidth,
                            material: Cesium.Color.LIGHTGRAY.withAlpha(gridOpacity)
                        }
                    });
                }
            }


            // Call the function to add grid lines
            addGridLines(MAP_BOUNDS.west, MAP_BOUNDS.east, MAP_BOUNDS.south, MAP_BOUNDS.north);

            // Add a multiselect dropdown for the dataset
            const datasetContainer = window.parent.document.getElementById('datasetContainer');

            // Create the dropdown menu
            const dropdown = document.createElement('select');
            dropdown.id = 'datasetDropdown';
            dropdown.multiple = true; // Allow multiple selections
            dropdown.style.width = '100%';
            datasetContainer.appendChild(dropdown);

            // Populate the dropdown menu with items from GEOJSON_NAMES
            PROXIES.forEach((proxyKey2) => {
                const nameKey = GEOJSON_NAMES[proxyKey2];
                const option = document.createElement('option');
                option.value = proxyKey2; // Use index as value for easier lookup
                option.textContent = getProxyTypeString(proxyKey2);
                option.selected = true; // Select all items by default
                dropdown.appendChild(option);
            });

            // Function to update marker visibility based on dropdown selection
            function updateMarkerVisibility() {
                const selectedOptions = Array.from(dropdown.selectedOptions).map(option => option.value);
                viewer.entities.values.forEach(entity => {
                    if (entity.customDatasetIndex !== undefined) {
                        if (selectedOptions.includes(entity.customDatasetIndex)) {
                            entity.billboard.color = Cesium.Color.WHITE.withAlpha(1.0); // Fully visible
                        } else {
                            entity.billboard.color = Cesium.Color.WHITE.withAlpha(0.0); // Fully transparent
                        }
                    }
                });
            }

            // Add an event listener to the dropdown to handle selection changes
            dropdown.addEventListener('change', updateMarkerVisibility);

            // Initialize marker visibility
            updateMarkerVisibility();


            // Define the corner points for the study area
            const corners = [
                createFormattedCoordinate(MAP_BOUNDS.north, MAP_BOUNDS.west, 'NW'),
                createFormattedCoordinate(MAP_BOUNDS.north, MAP_BOUNDS.east, 'NE'),
                createFormattedCoordinate(MAP_BOUNDS.south, MAP_BOUNDS.east, 'SE'),
                createFormattedCoordinate(MAP_BOUNDS.south, MAP_BOUNDS.west, 'SW')
            ];

            // Add corner markers as individual points with labels
            corners.forEach(corner => {
                viewer.entities.add({
                    position: Cesium.Cartesian3.fromDegrees(corner.lon, corner.lat, 0), // Set height to 0
                    point: {
                        pixelSize: 10,
                        color: Cesium.Color.RED
                    },
                    label: {
                        text: corner.label,
                        font: '10pt sans-serif',
                        fillColor: Cesium.Color.RED,
                        outlineColor: Cesium.Color.WHITE,
                        outlineWidth: 1,
                        style: Cesium.LabelStyle.FILL_AND_OUTLINE,
                        verticalOrigin: Cesium.VerticalOrigin.BOTTOM,
                        pixelOffset: new Cesium.Cartesian2(0, -20)
                    }
                });
            });

            viewer.scene.globe.frontFaceAlphaByDistance = new Cesium.NearFarScalar(50.0, 0.0, 100.0, 1.0);
            viewer.scene.globe.show = true;
            viewer.scene.fog.enabled = true;
            viewer.scene.globe.showGroundAtmosphere = false;
            viewer.scene.globe.baseColor = Cesium.Color.TRANSPARENT;
            viewer.animation.container.style.visibility = 'hidden';
            viewer.timeline.container.style.visibility = 'hidden';
            viewer.scene.globe.depthTestAgainstTerrain = false;

            // Center the camera on the midpoint of the study area, slightly south for a better 3D view
            const centerLon = (MAP_BOUNDS.west + MAP_BOUNDS.east) / 2;
            const centerLat = (MAP_BOUNDS.south + MAP_BOUNDS.north) / 2;  // Slightly south of center for better view

            // Center view button functionality
            window.document.getElementById('centeredViewButton1').addEventListener('click', centeredView);
            window.parent.document.getElementById('centeredViewButton').addEventListener('click', centeredView);


            function centeredView() {
                // Get the coordinates from the input box
                const lon = centerLon;
                const lat = centerLat;

                // Calculate the bounding box dimensions
                const width = MAP_BOUNDS.east - MAP_BOUNDS.west;
                const height = MAP_BOUNDS.north - MAP_BOUNDS.south;
                const maxDimension = Math.max(width, height);

                // Estimate height based on the bounding box size
                const estimatedHeight = maxDimension * 111000 * zoomOutFactor; // 111,000 meters per degree

                // Move the camera to the new coordinates with the estimated height
                viewer.camera.flyTo({
                    destination: Cesium.Cartesian3.fromDegrees(lon, lat, estimatedHeight),
                    orientation: {
                        heading: 0.0,
                        pitch: Cesium.Math.toRadians(-90.0), // Looking straight down
                        roll: 0.0
                    }
                });
            };
            centeredView()

            // North arrow rotation function based on camera heading
            function updateNorthArrow() {
                const heading = Cesium.Math.toDegrees(viewer.camera.heading);
                document.getElementById('northArrow').style.transform = `rotate(${-heading}deg)`;
            }

            // Initial north arrow update and binding to camera movement
            updateNorthArrow();
            viewer.scene.postRender.addEventListener(updateNorthArrow);

            // Override the home button functionality
            viewer.homeButton.viewModel.command.beforeExecute.addEventListener(function (e) {
                e.cancel = true; // Prevent the default home button action
                centeredView()

            });

            // Plot GeoJSON data with custom shape and color markers
            PROXIES.forEach((proxyKey) => {
                const geojsonUrl = GEOJSON_URLS[proxyKey]
                Cesium.GeoJsonDataSource.load(geojsonUrl, { clampToGround: true }).then((dataSource) => {
                    const uniqueLocationData = {};

                    dataSource.entities.values.forEach(entity => {
                        const properties = {};
                        entity.properties.propertyNames.forEach(propName => {
                            let value = entity.properties[propName].getValue();
                            properties[propName] = value;
                        });

                        // Store descriptions in entity for tooltip usage
                        entity.columnDefinitions = columnDefinitions;
                        if (Cesium.defined(entity.position)) {
                            const position = entity.position.getValue(Cesium.JulianDate.now());
                            const cartographic = Cesium.Cartographic.fromCartesian(position);
                            const lat = Cesium.Math.toDegrees(cartographic.latitude);
                            const lon = Cesium.Math.toDegrees(cartographic.longitude);
                            const coordKey = `${lat.toFixed(6)},${lon.toFixed(6)}`;

                            // Set initial transparency for each marker
                            entity.billboard.color = Cesium.Color.WHITE.withAlpha(initialTransparency);

                            if (!uniqueLocationData[coordKey]) {
                                uniqueLocationData[coordKey] = {
                                    lat,
                                    lon,
                                    properties: []
                                };
                            }

                            const properties = {};
                            entity.properties.propertyNames.forEach(propName => {
                                let value = entity.properties[propName].getValue();

                                // Check if the property key contains "Rank" and if the value is a number
                                if ((propName.includes("Rank") || propName.includes("Age")) && typeof value === "number") {
                                    value = parseFloat(value.toFixed(2)); // Round to one decimal place
                                }

                                properties[propName] = value;
                            });

                            uniqueLocationData[coordKey].properties.push(properties);
                        }
                    });
                    Object.keys(uniqueLocationData).forEach(coordKey => {
                        const location = uniqueLocationData[coordKey];
                        // Extract contact names and count unique ones
                        const contactNames = location.properties.map(property => {
                            const contactName = property["Contact Name"] || "Unknown Contact";
                            return contactName.includes('.') ? contactName.split('.')[0] : contactName;
                        });
                        const uniqueContactNames = new Set(contactNames);
                        const uniqueContactNamesCount = uniqueContactNames.size;

                        // Calculate marker size based on the uniqueContactNamesCount
                        const markerSize = baseMarkerSize + uniqueContactNamesCount;

                        let proxy = "Default";
                        let itemIndex = 0;
                        if (Object.keys(PROXY_TYPES[proxyKey]).length === 1 && proxyKey in PROXY_TYPES[proxyKey]) {
                            proxy = PROXY_TYPES[proxyKey][proxyKey];
                        } else {
                            const locationName = location.properties[0]["Evidence Type"];
                            const foundKey = Object.keys(PROXY_TYPES[proxyKey]).find(key => key === locationName);
                            if (foundKey) {
                                proxy = PROXY_TYPES[proxyKey][locationName];
                                itemIndex = Object.keys(PROXY_TYPES[proxyKey]).indexOf(locationName);
                            }
                        }


                        const shapeType = SHAPES[proxy];
                        const colorType = COLORS[proxy];
                        const markerImage = createImage(shapeType, colorType, markerSize);

                        // Set the eyeOffset inversely proportional to the marker size for rendering order
                        if (markerSize < 10) {
                            eyeOffsetValue = eyeOffsetFactor[0] * Math.exp(-markerSize / 5); // Very close for smallest markers
                        } else if (markerSize < 20) {
                            eyeOffsetValue = eyeOffsetFactor[1] * Math.log(1 / markerSize); // Moderate closeness for medium markers
                        } else {
                            eyeOffsetValue = eyeOffsetFactor[2]; // Minimal offset for largest markers
                        }
                        // const eyeOffsetValue = eyeOffsetFactor * Math.log(1000 / markerSize); // Logarithmic scaling

                        const marker = viewer.entities.add({
                            position: Cesium.Cartesian3.fromDegrees(location.lon, location.lat, 0),
                            billboard: {
                                image: markerImage,
                                width: markerSize,
                                height: markerSize,
                                color: Cesium.Color.WHITE, // Default color
                                scale: 1.0, // Default scale
                                eyeOffset: new Cesium.Cartesian3(0, 0, eyeOffsetValue), // Adjust for z-order
                                disableDepthTestDistance: Number.POSITIVE_INFINITY // Ensures visibility at all distances

                            },
                            customDatasetIndex: proxyKey // Set the dataset key here
                        });

                        // Store the properties as custom data for the popup
                        marker.customProperties = location.properties;

                    });

                    const uniqueLegendEntries = new Set();
                    function addToLegend(shape, color, description) {
                        const key = `${shape}-${color}-${description}`;
                        if (uniqueLegendEntries.has(key)) return;

                        uniqueLegendEntries.add(key);
                        const legendItem = document.createElement('div');
                        legendItem.style.display = 'flex';
                        legendItem.style.alignItems = 'center';
                        legendItem.style.marginBottom = '5px';

                        const iconCanvas = document.createElement('canvas');
                        iconCanvas.width = iconCanvas.height = 15;
                        const ctx = iconCanvas.getContext('2d');

                        ctx.fillStyle = color;
                        ctx.globalAlpha = 0.99;
                        ctx.strokeStyle = "black"; // Set stroke color to black
                        ctx.lineWidth = 1; // Set thickness of the stroke

                        switch (shape) {
                            case 'square': ctx.fillRect(0, 0, 15, 15); ctx.strokeRect(0, 0, 15, 15); break;
                            case 'circle': ctx.beginPath(); ctx.arc(7.5, 7.5, 7.5, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); break;
                            case 'semicircle': ctx.beginPath(); ctx.arc(7.5, 7.5, 7.5, 0, Math.PI); ctx.lineTo(7.5, 7.5); ctx.fill(); ctx.stroke(); break;
                            case 'triangle': ctx.beginPath(); ctx.moveTo(7.5, 0); ctx.lineTo(0, 15); ctx.lineTo(15, 15); ctx.fill(); ctx.stroke(); break;
                            case 'triangle-side': ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 15); ctx.lineTo(15, 7.5); ctx.fill(); ctx.stroke(); break;
                            case 'pentagon':
                                ctx.beginPath();
                                const centerX = 7.5;
                                const centerY = 7.5;
                                const radius = 7.5;
                                const sides = 5;
                                for (let i = 0; i < sides; i++) {
                                    const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                                    const x = centerX + radius * Math.cos(angle);
                                    const y = centerY + radius * Math.sin(angle);
                                    if (i === 0) {
                                        ctx.moveTo(x, y);
                                    } else {
                                        ctx.lineTo(x, y);
                                    }
                                }
                                ctx.closePath();
                                ctx.fill();
                                ctx.stroke();
                                break;
                            default: console.error('Invalid shape:', shape); break;
                        }

                        legendItem.appendChild(iconCanvas);
                        const text = document.createElement('span');
                        text.textContent = description;
                        text.style.marginLeft = '10px';
                        legendItem.appendChild(text);

                        document.getElementById('legend').appendChild(legendItem);
                    }
                    // Populate the legend
                    if (!legendDone) {
                        legendDone = true;
                        Object.keys(COLORS).forEach(value => {
                            addToLegend(SHAPES[value], COLORS[value], LABELS[value]);
                        });
                    }

                    // Click handler to display data in a custom popup and highlight the marker
                    viewer.screenSpaceEventHandler.setInputAction(async (movement) => {
                        let pickedLon = "N/A";
                        let pickedLat = "N/A";
                        const pickedObject = viewer.scene.pick(movement.position);
                        if (Cesium.defined(pickedObject) && pickedObject.id && pickedObject.id.customProperties) {
                            const propertiesList = pickedObject.id.customProperties;
                            const eventCount = propertiesList.length;

                            // Get the correct proxyKey
                            const proxyKey = pickedObject.id.customDatasetIndex;

                            // Get lat/lon of the picked point
                            const cartographic = Cesium.Cartographic.fromCartesian(
                                pickedObject.id.position.getValue(Cesium.JulianDate.now())
                            );

                            pickedLon = Cesium.Math.toDegrees(cartographic.longitude).toFixed(4);
                            pickedLat = Cesium.Math.toDegrees(cartographic.latitude).toFixed(4);

                            // Ensure column descriptions are loaded before proceeding
                            if (!columnDescriptionsByProxy[proxyKey]) {
                                console.log(`Waiting for column descriptions for proxy ${proxyKey}...`);
                                await loadColumnDescriptions();  // Wait until descriptions are loaded
                            }

                            // Get the correct column descriptions
                            const columnDescriptions = columnDescriptionsByProxy[proxyKey] || {};

                            // Reset the last highlighted marker if it exists
                            if (lastHighlightedMarker) {
                                lastHighlightedMarker.billboard.scale = 1.0;
                                lastHighlightedMarker.billboard.color = Cesium.Color.WHITE;
                            }

                            // Highlight the clicked marker
                            pickedObject.id.billboard.scale = 2.0;
                            pickedObject.id.billboard.color = Cesium.Color.BLACK;//.withAlpha(0.6);
                            pickedObject.id.billboard.disableDepthTestDistance = Number.POSITIVE_INFINITY;
                            lastHighlightedMarker = pickedObject.id;

                            var existingPopup = document.getElementById('popupContainer');
                            if (existingPopup) {
                                existingPopup.remove();
                            }

                            // Extract Contact Names
                            const contactNames = propertiesList.map(property => {
                                const contactName = property["Contact Name"] || `Event ${PROXIES.indexOf(proxyKey) + 1}`;
                                return contactName.includes('.') ? contactName.split('.')[0] : contactName;
                            });

                            // Normalize contact names: Remove trailing lowercase letters & '?' at the end
                            const normalizedContacts = contactNames.map(name => name.replace(/[a-z?]+$/, ""));
                            const uniqueContactNames = new Set(normalizedContacts); // Store only unique normalized contacts
                            const uniqueContactNamesCount = uniqueContactNames.size; // Get correct unique count


                            // Move "Contact Name" row to the top
                            const reorderedKeys = ["Contact Name", ...Object.keys(propertiesList[0]).filter(key => key !== "Contact Name")];

                            // Function to normalize keys: remove spaces, tabs, linefeeds, and convert to lowercase
                            function normalizeKey(key) {
                                return key
                                    .toLowerCase()  // Convert to lowercase
                                    .replace(/[\s\t\n\r]+/g, '')  // Remove spaces, tabs, and newlines
                                    .normalize("NFKC");  // Normalize Unicode characters
                            }

                            // Normalize column descriptions for easier lookup
                            const normalizedColumnDescriptions = {};
                            const normalizedDisplaySettings = {}; // Store display settings ("Yes" or "No")

                            Object.keys(columnDescriptions).forEach(key => {
                                const normalizedKey = normalizeKey(key);
                                normalizedColumnDescriptions[normalizedKey] = columnDescriptions[key].description;
                                normalizedDisplaySettings[normalizedKey] = columnDescriptions[key].display || "Yes"; // Default to "Yes"
                            });
                            // ✅ Ensure `hiddenRowIds` exists in the parent window
                            if (!window.parent.hiddenRowIds) {
                                window.parent.hiddenRowIds = [];
                            }
                            let tableHtml = `
<div id="popupContainer" style="width:100%;">
    <div style="display: flex; align-items: center; padding: 5px; background-color: #b3b3b3; position: sticky; top: 0; z-index: 2;">
        <button onclick="
    // Remove the popup from the parent window
    const popup = document.getElementById('popupContainer');
    if (popup) popup.remove();

    // Send a message to the iframe to reset the highlighted marker
    const iframe = document.getElementById('3dIframe');
    if (iframe && iframe.contentWindow) {
        iframe.contentWindow.postMessage({ action: 'resetHighlight' }, '*');
    } else {
        console.error('Iframe or its content is not accessible.');
    }

    // Update selected values and refresh the plot
    const selectedValues = getSelectedDatasetValues();
    plotData(selectedValues);
"
style="background-color: white; color: #333333; border: none; padding: 5px 5px; width:20px; cursor: pointer; font-size: 10px; font-weight: bold; margin-right: 10px;">X</button>

                <span style="color: #333333; font-weight: bold; margin-right: 10px;">
            ${uniqueContactNamesCount} Event${uniqueContactNamesCount > 1 ? 's' : ''} 
            (Longitude: ${pickedLon}, Latitude: ${pickedLat})
        </span>
        <!-- Checkbox to toggle hidden rows -->
<label for="toggleHiddenRows" style="margin-left: 10px; font-size: 12px; color: black; display: inline-flex; align-items: center;"> Show&nbsp;Hidden&nbsp;Rows:&nbsp;
    <input type="checkbox" id="toggleHiddenRows" style="margin-right: 4px;" onchange="
        window.parent.hiddenRowIds.forEach(rowId => {
            const row = document.getElementById(rowId);
            if (row) {
                row.style.display = this.checked ? 'table-row' : 'none';
            } else {
                console.warn('Row with ID ' + rowId + ' not found.');
            }
        });
    ">
   
</label>

    </div>

    <div id="tableContainer" style="overflow:auto; overflow-x: scroll; overflow-y: scroll;">
        <table style="border-collapse: collapse; width: 100%; height:100%;">
            <thead>
                <tr style="background-color: wnte; position: sticky; top: 0; z-index: 1;">
                    <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd; background-color: #b3b3b3; position: sticky; left: 0; z-index: 2;"
                        title="${normalizedColumnDescriptions[normalizeKey('Contact Name')] || 'This column represents Contact Names'}">
                        Contact Name
                    </th>
                    ${contactNames.map(contactName => `
                        <th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;"
                            title="${normalizedColumnDescriptions[normalizeKey(contactName)] || contactName}">
                            ${contactName}
                        </th>
                    `).join('')}
                </tr>
            </thead>
            <tbody>
                ${reorderedKeys
                                    .filter(key => key !== "Contact Name") // Exclude "Contact Name" row
                                    .map((key, rowIndex) => {
                                        const normalizedKey = normalizeKey(key);
                                        const rowStyle = normalizedDisplaySettings[normalizedKey] === "No" ? 'style="display: none;"' : '';
                                        const isHidden = normalizedDisplaySettings[normalizedKey] === "No";

                                        if (isHidden && !window.parent.hiddenRowIds.includes(normalizedKey)) {
                                            window.parent.hiddenRowIds.push(normalizedKey); // ✅ Store hidden row ID in parent
                                        }
                                        return `
                        <tr id="${normalizedKey}" ${rowStyle} style="background-color: ${rowIndex % 2 === 0 ? '#f1f1f1' : '#e9e9e9'};">
                            <td style="padding: 10px; border-bottom: 1px solid #ddd; color: #333; font-weight: bold; background-color: ${isHidden ? '#d3d3d3' : '#b3b3b3'}; position: sticky; left: 0; z-index: 1;" 
                                title="${normalizedColumnDescriptions[normalizedKey] || key}">
                                ${key}
                            </td>
                            ${propertiesList.map(property => `
                                <td style="padding: 10px; border-bottom: 1px solid #ddd; color: #333;"
                                    title="${normalizedColumnDescriptions[normalizedKey] || key}">
                                    ${property[key] ?? '-'}
                                </td>
                            `).join('')}
                        </tr>`;
                                    }).join('')}
            </tbody>
        </table>
    </div>
</div>`;


                            if (hasParent) {
                                const parentDoc = window.parent.document;
                                const fileTable = parentDoc.getElementById('infobox');

                                if (fileTable) {
                                    fileTable.innerHTML = tableHtml;
                                } else {
                                    console.error("Element with ID 'infobox' not found in parent document.");
                                }
                            } else {
                                document.body.insertAdjacentHTML('beforeend', tableHtml);
                            }
                        }
                    }, Cesium.ScreenSpaceEventType.LEFT_CLICK);

                }).catch(console.error);
            });

            // Function to set marker transparency for a specific dataset
            function setMarkerTransparency(datasetIndex, transparency) {
                viewer.entities.values.forEach(entity => {
                    if (entity.customDatasetIndex === datasetIndex && entity.billboard) {
                        entity.billboard.color = Cesium.Color.WHITE.withAlpha(transparency);
                    }
                });
            }

            // Add a unique shape-color entry to the legend
            const uniqueLegendEntries = new Set();
            function addToLegend(shape, color, description) {
                const key = `${shape}-${color}-${description}`;
                if (uniqueLegendEntries.has(key)) return;

                uniqueLegendEntries.add(key);
                const legendItem = document.createElement('div');
                legendItem.style.display = 'flex';
                legendItem.style.alignItems = 'center';
                legendItem.style.marginBottom = '5px';

                const iconCanvas = document.createElement('canvas');
                iconCanvas.width = iconCanvas.height = 20;
                const ctx = iconCanvas.getContext('2d');

                ctx.fillStyle = color;
                ctx.strokeStyle = "black"; // Set stroke color to black
                ctx.lineWidth = 1; // Set thickness of the stroke
                ctx.globalAlpha = 0.99; // Set transparency for fill
                switch (shape) {
                    case 'square': ctx.fillRect(0, 0, 20, 20); ctx.strokeRect(0, 0, 15, 15); break;
                    case 'circle': ctx.beginPath(); ctx.arc(10, 10, 10, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); break;
                    case 'semicircle': ctx.beginPath(); ctx.arc(10, 10, 10, 0, Math.PI); ctx.lineTo(10, 10); ctx.fill(); ctx.stroke(); break;
                    case 'triangle': ctx.beginPath(); ctx.moveTo(10, 0); ctx.lineTo(0, 20); ctx.lineTo(20, 20); ctx.fill(); ctx.stroke(); break;
                    case 'triangle-side': ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, 20); ctx.lineTo(20, 10); ctx.fill(); ctx.stroke(); break;
                    case 'pentagon':
                        ctx.beginPath();
                        const centerX = 10;
                        const centerY = 10;
                        const radius = 10;
                        const sides = 5;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    default: console.error('Invalid shape:', shape); break;
                }

                legendItem.appendChild(iconCanvas);
                const text = document.createElement('span');
                text.textContent = description;
                text.style.marginLeft = '10px';
                legendItem.appendChild(text);

                document.getElementById('legend').appendChild(legendItem);
            }

            // Create a shape icon
            function createImage(shape, color, size) {
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                canvas.width = canvas.height = size;

                ctx.fillStyle = color;
                ctx.globalAlpha = 0.99;
                ctx.strokeStyle = "black"; // Set stroke color to black
                ctx.lineWidth = 1; // Set thickness of the stroke

                switch (shape) {
                    case 'square': ctx.fillRect(0, 0, size, size); ctx.strokeRect(0, 0, 15, 15); break;
                    case 'circle': ctx.beginPath(); ctx.arc(size / 2, size / 2, size / 2, 0, 2 * Math.PI); ctx.fill(); ctx.stroke(); break;
                    case 'semicircle': ctx.beginPath(); ctx.arc(size / 2, size / 2, size / 2, 0, Math.PI); ctx.lineTo(size / 2, size / 2); ctx.fill(); ctx.stroke(); break;
                    case 'triangle': ctx.beginPath(); ctx.moveTo(size / 2, 0); ctx.lineTo(0, size); ctx.lineTo(size, size); ctx.fill(); ctx.stroke(); break;
                    case 'triangle-side': ctx.beginPath(); ctx.moveTo(0, 0); ctx.lineTo(0, size); ctx.lineTo(size, size / 2); ctx.fill(); ctx.stroke(); break;
                    case 'pentagon':
                        ctx.beginPath();
                        const centerX = size / 2;
                        const centerY = size / 2;
                        const radius = size / 2;
                        const sides = 5;
                        for (let i = 0; i < sides; i++) {
                            const angle = (i * 2 * Math.PI) / sides - Math.PI / 2;
                            const x = centerX + radius * Math.cos(angle);
                            const y = centerY + radius * Math.sin(angle);
                            if (i === 0) {
                                ctx.moveTo(x, y);
                            } else {
                                ctx.lineTo(x, y);
                            }
                        }
                        ctx.closePath();
                        ctx.fill();
                        ctx.stroke();
                        break;
                    default: console.error('Invalid shape:', shape); break;
                }
                return canvas.toDataURL();
            }
        });


        function clearHighlight() {
            if (lastHighlightedMarker) {
                lastHighlightedMarker.billboard.scale = 1.0; // Reset to original scale
                lastHighlightedMarker.billboard.color = Cesium.Color.WHITE; // Reset to original color
                lastHighlightedMarker = null; // Clear the highlighted marker reference
            };
            if (lastHighlightedBarMarkers.length > 0) {
                lastHighlightedBarMarkers.forEach(marker => {
                    marker.billboard.scale = 1.0;
                    marker.billboard.color = Cesium.Color.WHITE;
                });
                lastHighlightedBarMarkers = []; // Clear previous highlights
            }
        }
        window.addEventListener("message", function (event) {
            if (event.data.action === "resetHighlight") {
                if (lastHighlightedMarker) {
                    lastHighlightedMarker.billboard.scale = 1.0;
                    lastHighlightedMarker.billboard.color = Cesium.Color.WHITE;
                    lastHighlightedMarker = null; // Clear reference
                }
            }
        });




    </script>
</body>

</html>