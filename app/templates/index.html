{% extends 'cpal_page.html' %}

{% block style%}
<link rel="stylesheet" href="/static/css/repository.css" />
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/css/select2.min.css" />
<script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
<script>
    // Unique flag only for this page
    window.SKIP_CESIUM = { skip: true };
</script>

<!-- Load config.js synchronously -->
<script>
    console.log("Starting the script ");
    let branch = "{{ branch }}";
    let configFilePath = `/static/config/${branch === "main" ? "" : branch + "/"}config.js`;

    if (branch !== "main") {
        // console.warn("[WARN] Loading configuration from branch:", branch, configFilePath);
    }

    let xhr = new XMLHttpRequest();
    xhr.open('GET', configFilePath, false); // synchronous
    xhr.onload = function () {
        if (xhr.status === 200) {
            let script = document.createElement('script');
            script.text = xhr.responseText;
            document.head.appendChild(script);
        } else {
            console.error("Failed to load config.js");
        }
    };
    xhr.send(null);
</script>

{% endblock %}
{% block description %}
<div class="info-message">
</div>
<div class="description">

    <h2>CPAL Paleoseismic Compilation</h2>

    <p>The Paleoseismology Group at Cascadia Quakes specializes in studying past earthquake events through geological
        evidence,
        enhancing our understanding of seismic hazards in the Cascadia Subduction Zone. Our research focuses on
        analyzing
        ancient fault lines, sediment layers, and other geological markers to improve predictions of future seismic
        activity and
        to inform strategies for earthquake preparedness and risk mitigation.</p>
    <p>
        The map on this page displays the USGS and CPAL's <a
            href="https://www.sciencebase.gov/catalog/item/64261ec8d34e370832ff6232" target="_blank">latest
            compilation</a> of
        paleoseismic proxies, represented by distinct symbols and colors. Click on a marker to explore its associated
        dataset. Use the map controls below to refine
        the display and focus on your desired dataset (click on <strong><span style="color:red;">▶</span>
            Show/Hide
            Dataset
            & Plot Controls</strong> to toggle the controls). As you
        zoom in and encounter overlapping markers, right-click near the marker cluster to spread out the markers.
        Right-click
        again to return the markers to their original positions.
    </p>
    <p>
        Additional controls above the map include:
    </p>
    <ul>
        <li><strong>View Home</strong> – Resets the map zoom and viewport to the default setting.</li>
        <li><strong>Clear Highlight</strong> – Removes highlights from all previously highlighted markers.</li>
        <li><strong>Group Markers</strong> – Returns markers that have been spread out back to their original positions
            (similar to a second right-click).</li>
        <li><strong>Spread Offset</strong> – Adjusts the distance between spread-out markers, allowing you to fine-tune
            based on zoom level.</li>
        <li><strong>Select a Site</strong> (dropdown) – Zooms in to a selected site from the list.</li>
    </ul>

</div>
{% endblock %}
{% block filter %}
<div id="toggleFilterPanel" onclick="toggleFilterPanel()" class="filterToggleBtn">
    <span style="color: red;">&#9660;&nbsp;</span>Show/Hide Dataset &amp; Plot Controls
</div>
<div id="filterPanel" style="display:block;">
    <div id="controlContainer">

        <div class="three-column-container">
            <!-- Column 1 -->
            <div class="column">
                <h3>Data:</h3>
                <div id="fileTable" class="modelSelect"><b>Selected Dataset(s):</b>
                    <div id="datasetContainer" style="margin-top: 5pt;"></div>
                </div>
                <div class="sliderContainer" style="font-weight: bold; display:block;"></div>
                <div style="margin-top: 10px;">
                    <label for="latRange">Latitude Range:</label>
                    <input type="number" id="latMinSlider" step="0.1" style="width: 80px;">°
                    to
                    <input type="number" id="latMaxSlider" step="0.1" style="width: 80px;">°
                </div>

                <div style="margin-top: 10px;">
                    <label for="lonRange">Longitude Range:</label>
                    <input type="number" id="lonMinSlider" step="0.1" style="width: 80px;">°
                    to
                    <input type="number" id="lonMaxSlider" step="0.1" style="width: 80px;">°
                </div>
            </div>

            <!-- Column 2 -->
            <div class="column">
                <h3>Filters:</h3>

                <div style="margin-top: 10px;">
                    <label for="siteEvidenceRankFilter">Site-Averaged Evidence Rank:</label>
                    <select id="siteEvidenceRankFilter">
                        <option value="0" selected>Show All (0+)</option>
                        <option value="1">1+</option>
                        <option value="2">2+</option>
                        <option value="3">3+</option>
                    </select>
                </div>
                <div style="margin-top: 10px;">
                    <label for="ageRankFilter">Age Rank:</label>
                    <select id="ageRankFilter">
                        <option value="0" selected>Show All (0+)</option>
                        <option value="1">1+</option>
                        <option value="2">2+</option>
                        <option value="3">3+</option>
                        <option value="4">4+</option>
                        <option value="5">5+</option>
                    </select>
                </div>
                <div style="margin-top: 10px;">
                    <label for="evidenceRankFilter">Evidence Rank:</label>
                    <select id="evidenceRankFilter">
                        <option value="0" selected>Show All (0+)</option>
                        <option value="1">1+</option>
                        <option value="2">2+</option>
                        <option value="3">3+</option>
                    </select>
                </div>
            </div>

            <!-- Column 3 -->
            <div class="column">
                <h3>Plot:</h3>

                <div>
                    <label for="xAxisSelector">Chart Type:</label>
                    <select id="xAxisSelector">
                        <option value="events">Number of Events</option>
                        <option value="length">Length of Record</option>
                    </select>
                </div>
                <button id="downloadGeoJSON" style="width:51%;">Download Filtered Data\n(GeoJSON)</button>

                <button id="toggleGuideButton" style="width:51%;" onclick="toggleGuide()">Help</button>
                <div id="chartUserGuide" style="display: none; margin-top: 10px;">
                    <h3>User Guide: Interactive Latitude Chart</h3>
                    <p>
                        The <strong>Interactive Latitude Chart</strong> allows you to visualize data
                        distributions
                        across latitude bins.
                        You can customize the chart type to display either:
                    </p>
                    <ol>
                        <li>
                            <strong>Number of Events:</strong> The total count of events occurring within each
                            latitude
                            range.
                        </li>
                        <li>
                            <strong>Length of Record:</strong> The cumulative length of records in
                            <em>calibrated years BP (cal yr BP)</em> for events within each latitude range.
                            This metric always uses the absolute value of the record length.
                        </li>
                    </ol>
                    <p>To interact with the chart:</p>
                    <ul>
                        <li>
                            <strong>Select chart type:</strong> Use the dropdown menu to choose between
                            "Number of
                            Events" or "Length of Record."
                        </li>
                        <li>
                            <strong>View Details:</strong> Hover over bars in the chart to view detailed data
                            for each
                            latitude bin.
                        </li>
                    </ul>
                    <p>
                        The Y-axis represents latitude, with lower latitudes at the bottom and higher latitudes
                        at the
                        top.
                        The X-axis dynamically adjusts based on the selected chart type. Use this chart to gain
                        insights
                        into spatial distributions and data trends related to your selected datasets.
                    </p>
                </div>
            </div>
        </div>
    </div>
</div>



</div>
</div>
{% endblock %}
{% block leftpanel %}
<div id="fileListPanel">
    <div>
        <div id="infobox"></div>
    </div>
</div>
{% endblock %}
{% block rightpanel %}
<div id="contentPanel">
    <span id="cmodelname" style="display:none;"></span>CRESCENT Paleoseismic Dataset(s)
    <div id="results-panel" class="action_side" style="flex:0 0 67.5%;">
        <iframe src="/map3d" width="99.5%" height="1200px" id="3dIframe"
            sandbox="allow-scripts allow-same-origin allow-popups"></iframe>
    </div>
</div>
{% endblock %}
{% block scripts %}
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.5.1/jquery.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/select2/4.0.13/js/select2.min.js"></script>
<script src="/static/config/project.js"></script>
<script>
    // --- UI helpers ---

    function toggleGuide() {
        const guideDiv = document.getElementById("chartUserGuide");
        const button = document.getElementById("toggleGuideButton");
        if (guideDiv.style.display === "none") {
            guideDiv.style.display = "block";
            button.textContent = "Hide Help";
        } else {
            guideDiv.style.display = "none";
            button.textContent = "Help";
        }
    }

    function toggleFilterPanel() {
        var filterPanel = document.getElementById("filterPanel");
        var button = document.getElementById("toggleFilterPanel");
        if (filterPanel.style.display === "none") {
            filterPanel.style.display = "block";
            button.innerHTML = '<span style="color:red;">&#9660;&nbsp;</span>Show/Hide Dataset &amp; Plot Controls';
        } else {
            filterPanel.style.display = "none";
            button.innerHTML = '<span style="color:red;">&#9654;&nbsp;</span>Show/Hide Dataset &amp; Plot Controls';
        }
    }

    // Send highlight request to iframe
    function highlightMarkerOnMap(siteNames, evidenceType) {
        const iframe = document.getElementById('3dIframe');
        if (iframe && iframe.contentWindow) {
            iframe.contentWindow.postMessage({ action: "highlightMarker", sites: siteNames, evidence: evidenceType }, "*");
        } else {
            console.error("Iframe or map is not accessible.");
        }
    }

    // --- Data utilities used by plotting ---

    function getValidNumber(value) {
        if (typeof value === "string") {
            value = value.trim();
        }
        const num = parseFloat(value);
        return isNaN(num) ? null : num;
    }

    // One canonical version of createLatitudeBins
    function createLatitudeBins(south, north, step = 0.1) {
        const bins = [];
        for (let lat = south; lat <= north; lat += step) {
            bins.push(lat);
        }
        return bins;
    }

    // Bin features in latitude and aggregate by site/evidenceType
    function computeDataByLatitudeBin(features, bins, metric) {
        const binCounts = {};

        const minEvidenceRank = parseFloat(parseFloat(document.getElementById("evidenceRankFilter").value).toFixed(1));
        const minAgeRank = parseFloat(parseFloat(document.getElementById("ageRankFilter").value).toFixed(1));
        const minSiteEvidenceRank = parseFloat(parseFloat(document.getElementById("siteEvidenceRankFilter").value).toFixed(1));

        // Step 1: determine max ranks per (site, evidenceType)
        const maxRanks = {};

        features.forEach(feature => {
            const site = feature.properties["Site"] || "Unknown";
            const evidenceType = feature.properties["Evidence Type"] || "Unknown";

            const siteEvidenceRank = getValidNumber(
                feature.properties["Site-Averaged Evidence Rank (0 - 3)"] ??
                feature.properties["Site-Averaged Evidence Rank(0 - 3)"]
            );
            const ageRank = getValidNumber(
                feature.properties["Age Rank (0 - 5)"] ??
                feature.properties["Age Rank(0 - 5)"]
            );
            const evidenceRank = getValidNumber(
                feature.properties["Evidence Rank (0 - 3)"] ??
                feature.properties["Evidence Rank(0 - 3)"]
            );

            if (siteEvidenceRank === null && ageRank === null && evidenceRank === null) {
                return;
            }

            const key = `${site}-${evidenceType}`;
            if (!maxRanks[key]) {
                maxRanks[key] = { maxEvidenceRank: 0, maxAgeRank: 0, maxSiteEvidenceRank: 0 };
            }

            if (evidenceRank !== null) maxRanks[key].maxEvidenceRank = Math.max(maxRanks[key].maxEvidenceRank, evidenceRank);
            if (ageRank !== null) maxRanks[key].maxAgeRank = Math.max(maxRanks[key].maxAgeRank, ageRank);
            if (siteEvidenceRank !== null) maxRanks[key].maxSiteEvidenceRank = Math.max(maxRanks[key].maxSiteEvidenceRank, siteEvidenceRank);
        });

        // Step 2: filter & bin
        features.forEach(feature => {
            const lat = feature.geometry.coordinates[1];

            let site = feature.properties["Site"] || "Unknown";
            let contactName = feature.properties["Contact Name"] || "Unknown";
            let evidenceType = feature.properties["Evidence Type"] || "Unknown";

            const key = `${site}-${evidenceType}`;

            if (
                maxRanks[key].maxEvidenceRank < minEvidenceRank ||
                maxRanks[key].maxAgeRank < minAgeRank ||
                maxRanks[key].maxSiteEvidenceRank < minSiteEvidenceRank
            ) {
                return;
            }

            let rawLength = feature.properties["Length of Record"] || "0";
            let length = 0;
            if (typeof rawLength === 'string') {
                length = parseFloat(rawLength.replace(/[~<>]/g, "")) || 0;
            } else if (typeof rawLength === 'number') {
                length = rawLength;
            }
            let increment = metric === "length" ? length : 1;

            let normalizedContact = contactName.replace(/[a-z?]+$/, "");

            for (let i = 0; i < bins.length - 1; i++) {
                if (lat >= bins[i] && lat < bins[i + 1]) {
                    const binMidpoint = (bins[i] + bins[i + 1]) / 2;

                    if (!binCounts[binMidpoint]) {
                        binCounts[binMidpoint] = {};
                    }
                    if (!binCounts[binMidpoint][evidenceType]) {
                        binCounts[binMidpoint][evidenceType] = {};
                    }
                    if (!binCounts[binMidpoint][evidenceType][site]) {
                        binCounts[binMidpoint][evidenceType][site] = {
                            total: 0,
                            count: 0,
                            totalCount: 0,
                            uniqueContacts: new Set()
                        };
                    }

                    const siteBucket = binCounts[binMidpoint][evidenceType][site];

                    if (!siteBucket.uniqueContacts.has(normalizedContact)) {
                        siteBucket.uniqueContacts.add(normalizedContact);
                        siteBucket.count += 1;
                    }

                    if (metric === "length") {
                        siteBucket.total = increment;
                    } else {
                        siteBucket.total += increment;
                    }
                    siteBucket.totalCount += 1;
                    break;
                }
            }
        });

        return binCounts;
    }

    // Datasets selected in the multi-select injected from the iframe
    function getSelectedDatasetValues() {
        const selectionBox = document.getElementById('datasetDropdown');
        if (selectionBox && selectionBox.selectedOptions.length > 0) {
            const selectedOptions = Array.from(selectionBox.selectedOptions);
            return selectedOptions.map(option => option.value);
        }
        // Default to all datasets if none explicitly selected yet
        return Object.keys(PROXY_TYPES);
    }

    // Filter features by current lat/lon slider range
    function filterDataByRange(features) {
        const latMin = parseFloat(document.getElementById("latMinSlider").value);
        const latMax = parseFloat(document.getElementById("latMaxSlider").value);
        const lonMin = parseFloat(document.getElementById("lonMinSlider").value);
        const lonMax = parseFloat(document.getElementById("lonMaxSlider").value);

        return features.filter(feature => {
            const lat = feature.geometry.coordinates[1];
            const lon = feature.geometry.coordinates[0];
            return lat >= latMin && lat <= latMax && lon >= lonMin && lon <= lonMax;
        });
    }

    // Main plotting function (chart)
    function plotData(selectedValues) {
        const geojsonFetchPromises = [];
        const southBound = (typeof MAP_BOUNDS !== "undefined" ? MAP_BOUNDS.south : (typeof south !== "undefined" ? south : -90));
        const northBound = (typeof MAP_BOUNDS !== "undefined" ? MAP_BOUNDS.north : (typeof north !== "undefined" ? north : 90));
        const bins = createLatitudeBins(southBound, northBound, 0.1);
        const binData = {};
        const evidenceTypes = new Set();
        const metric = document.getElementById("xAxisSelector").value;

        const latMin = parseFloat(document.getElementById("latMinSlider").value);
        const latMax = parseFloat(document.getElementById("latMaxSlider").value);
        const lonMin = parseFloat(document.getElementById("lonMinSlider").value);
        const lonMax = parseFloat(document.getElementById("lonMaxSlider").value);

        if (!selectedValues || selectedValues.length === 0) {
            geojsonFetchPromises.push(Promise.resolve());
        }

        (selectedValues || []).forEach(value => {
            const geojsonUrl = GEOJSON_URLS[value];

            if (!geojsonUrl) {
                console.warn("No GEOJSON_URL for dataset:", value);
                return;
            }

            const fetchPromise = fetch(geojsonUrl)
                .then(response => response.json())
                .then(geojson => {
                    const spatiallyFilteredFeatures = geojson.features.filter(feature => {
                        const lat = feature.geometry.coordinates[1];
                        const lon = feature.geometry.coordinates[0];
                        return lat >= latMin && lat <= latMax && lon >= lonMin && lon <= lonMax;
                    });

                    const binCounts = computeDataByLatitudeBin(spatiallyFilteredFeatures, bins, metric);

                    Object.keys(binCounts).forEach(binMidpoint => {
                        if (!binData[binMidpoint]) {
                            binData[binMidpoint] = {};
                        }

                        Object.keys(binCounts[binMidpoint]).forEach(evidenceType => {
                            if (!binData[binMidpoint][evidenceType]) {
                                binData[binMidpoint][evidenceType] = {};
                            }

                            binData[binMidpoint][evidenceType] = binCounts[binMidpoint][evidenceType];
                            evidenceTypes.add(evidenceType);
                        });
                    });
                });

            geojsonFetchPromises.push(fetchPromise);
        });

        Promise.all(geojsonFetchPromises).then(() => {
            const sortedBins = Object.keys(binData)
                .map(parseFloat)
                .sort((a, b) => b - a);

            const datasets = [];

            evidenceTypes.forEach(evidenceType => {
                sortedBins.forEach(binMidpoint => {
                    Object.entries(binData[binMidpoint][evidenceType] || {}).forEach(([site, siteData]) => {
                        let count = siteData.count;
                        let total = siteData.total;
                        let totalCount = siteData.totalCount;
                        let avgLength = metric === "length" ? total : total;

                        datasets.push({
                            label: [`${evidenceType}`],
                            data: [{ y: binMidpoint, x: avgLength, site: site }],
                            backgroundColor: COLORS[evidenceType] || "#7F8C8D",
                            borderColor: "black",
                            borderWidth: 1,
                            hoverBorderColor: "red",
                            hoverBorderWidth: 8,
                            siteData: [{
                                site: site,
                                value: avgLength,
                                totalRecords: total,
                                count: count,
                                totalCount: totalCount
                            }]
                        });
                    });
                });
            });

            const infobox = document.getElementById("infobox");
            infobox.innerHTML = "";

            const canvas = document.createElement("canvas");
            canvas.id = "latitudeChart";
            canvas.style.width = "100%";
            canvas.style.height = "900px";
            infobox.appendChild(canvas);

            const valueLabel = metric === "length" ? "Length of Record" : "Total Number of Events";
            const xAxisTitle = valueLabel;

            const rawMinLatitude = parseFloat(document.getElementById("latMinSlider").value);
            const rawMaxLatitude = parseFloat(document.getElementById("latMaxSlider").value);
            const stepSize = 0.5;

            const minLatitude = Math.floor(rawMinLatitude / stepSize) * stepSize;
            const maxLatitude = Math.ceil(rawMaxLatitude / stepSize) * stepSize;

            new Chart(canvas, {
                type: "bar",
                data: { datasets },
                options: {
                    indexAxis: "y",
                    maintainAspectRatio: false,
                    responsive: true,
                    scales: {
                        x: {
                            title: { display: true, text: xAxisTitle },
                            beginAtZero: true,
                            stacked: true,
                            barPercentage: 1.0,
                            categoryPercentage: 0.9
                        },
                        y: {
                            title: { display: true, text: "Latitude" },
                            stacked: true,
                            reverse: false,
                            type: "linear",
                            min: minLatitude,
                            max: maxLatitude,
                            ticks: {
                                stepSize: stepSize,
                                callback: value => value.toFixed(1)
                            }
                        }
                    },
                    plugins: {
                        legend: { display: false, position: "bottom" },
                        tooltip: {
                            enabled: true,
                            mode: "point",
                            intersect: true,
                            callbacks: {
                                title: function (tooltipItems) {
                                    let latitude = tooltipItems[0].label;
                                    return `Latitude: ${latitude}`;
                                },
                                label: function (context) {
                                    let dataset = context.dataset;
                                    let site = dataset.siteData[context.dataIndex]?.site || "Unknown";
                                    let value = context.raw.x;
                                    let totalRecords = dataset.siteData[context.dataIndex]?.totalRecords || 0;
                                    let totalCount = dataset.siteData[context.dataIndex]?.totalCount || 1;
                                    let count = dataset.siteData[context.dataIndex]?.count || 1;

                                    let displayValue = metric === "length"
                                        ? `Length of Record: ${totalRecords.toFixed(1)}`
                                        : `Events: ${count}`;

                                    return [
                                        `Evidence Type: ${dataset.label}`,
                                        `Site: ${site}`,
                                        displayValue
                                    ];
                                }
                            }
                        }
                    },
                    hover: {
                        mode: "point",
                        intersect: true
                    },
                    onClick: function (event, elements) {
                        if (elements.length > 0) {
                            const datasetIndex = elements[0].datasetIndex;
                            const dataIndex = elements[0].index;
                            const dataset = datasets[datasetIndex];
                            const selectedSite = dataset.data[dataIndex]?.site;
                            const evidenceType = dataset.label || "Unknown";

                            if (selectedSite) {
                                highlightMarkerOnMap([selectedSite], evidenceType);
                            }
                        }
                    }
                }
            });

        }).catch(error => console.error("Error plotting data:", error));
    }

    // Update markers in iframe based on current filters
    function updateMapMarkers() {
        const iframe = document.getElementById("3dIframe");
        if (!iframe || !iframe.contentWindow) {
            console.error("Iframe not accessible for updating markers.");
            return;
        }

        const latMin = parseFloat(document.getElementById("latMinSlider").value);
        const latMax = parseFloat(document.getElementById("latMaxSlider").value);
        const lonMin = parseFloat(document.getElementById("lonMinSlider").value);
        const lonMax = parseFloat(document.getElementById("lonMaxSlider").value);
        const minEvidenceRank = parseInt(document.getElementById("evidenceRankFilter").value, 10);
        const minAgeRank = parseInt(document.getElementById("ageRankFilter").value, 10);
        const minSiteEvidenceRank = parseInt(document.getElementById("siteEvidenceRankFilter").value, 10);

        const messagePayload = {
            latMin, latMax, lonMin, lonMax,
            minEvidenceRank, minAgeRank, minSiteEvidenceRank
        };

        iframe.contentWindow.postMessage({
            action: "updateMarkers",
            ...messagePayload
        }, "*");

        iframe.contentWindow.postMessage({
            action: "updateSelectionOverlay",
            ...messagePayload
        }, "*");
    }

    // Combined updater: chart + map
    function updatePlot() {
        const selectedValues = getSelectedDatasetValues();
        plotData(selectedValues);
        updateMapMarkers();
    }

    // Download currently filtered GeoJSON (all selected datasets, filtered to lat/lon)
    function downloadGeoJSON() {
        function getFilteredGeoJSON() {
            const selectedValues = getSelectedDatasetValues();
            let filteredFeatures = [];

            if (!selectedValues || selectedValues.length === 0) {
                console.warn("No datasets selected. Download will be empty.");
                return Promise.resolve({ type: "FeatureCollection", features: [] });
            }

            console.log("Fetching datasets for GeoJSON download:", selectedValues);

            const geojsonFetchPromises = selectedValues.map(value => {
                const geojsonUrl = GEOJSON_URLS[value];

                if (!geojsonUrl) {
                    console.warn("No GEOJSON_URL for dataset:", value);
                    return Promise.resolve();
                }

                return fetch(geojsonUrl)
                    .then(response => {
                        if (!response.ok) {
                            throw new Error(`Failed to load ${geojsonUrl}`);
                        }
                        return response.json();
                    })
                    .then(geojson => {
                        filteredFeatures.push(...filterDataByRange(geojson.features));
                    })
                    .catch(error => {
                        console.error(`Error fetching ${geojsonUrl}:`, error);
                    });
            });

            return Promise.all(geojsonFetchPromises).then(() => {
                console.log(`Filtered features count: ${filteredFeatures.length}`);
                return {
                    type: "FeatureCollection",
                    features: filteredFeatures
                };
            });
        }

        getFilteredGeoJSON().then(filteredGeoJSON => {
            if (!filteredGeoJSON || !filteredGeoJSON.features || filteredGeoJSON.features.length === 0) {
                console.warn("No data available for download.");
                return;
            }

            console.log(`Preparing to download ${filteredGeoJSON.features.length} features...`);

            try {
                const geojsonStr = JSON.stringify(filteredGeoJSON, null, 2);
                const blob = new Blob([geojsonStr], { type: "application/json" });
                const url = URL.createObjectURL(blob);

                const a = document.createElement("a");
                a.href = url;
                a.download = "filtered_data.geojson";
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log("Download completed successfully.");
            } catch (error) {
                console.error("Error generating GeoJSON file:", error);
                alert("Error generating GeoJSON file.");
            }
        }).catch(error => {
            console.error("Error in GeoJSON processing:", error);
            alert("Failed to download GeoJSON.");
        });
    }

    // Initialize lat/lon sliders using MAP_BOUNDS
    function initializeSliders() {
        if (typeof MAP_BOUNDS === "undefined") {
            console.error("MAP_BOUNDS is not defined. Retrying in 100ms...");
            setTimeout(initializeSliders, 100);
            return;
        }

        const latMinSlider = document.getElementById("latMinSlider");
        const latMaxSlider = document.getElementById("latMaxSlider");
        const lonMinSlider = document.getElementById("lonMinSlider");
        const lonMaxSlider = document.getElementById("lonMaxSlider");

        const south = MAP_BOUNDS.south;
        const north = MAP_BOUNDS.north;
        const west = MAP_BOUNDS.west;
        const east = MAP_BOUNDS.east;

        latMinSlider.min = south;
        latMinSlider.max = north;
        latMinSlider.value = south;

        latMaxSlider.min = south;
        latMaxSlider.max = north;
        latMaxSlider.value = north;

        lonMinSlider.min = west;
        lonMinSlider.max = east;
        lonMinSlider.value = west;

        lonMaxSlider.min = west;
        lonMaxSlider.max = east;
        lonMaxSlider.value = east;

        latMinSlider.addEventListener("change", () => {
            let val = parseFloat(latMinSlider.value);
            let val_max = parseFloat(latMaxSlider.value);
            if (val < south) val = south;
            if (val > val_max) val = val_max;
            latMinSlider.value = val;
            updatePlot();
        });

        latMaxSlider.addEventListener("change", () => {
            let val = parseFloat(latMaxSlider.value);
            let val_min = parseFloat(latMinSlider.value);
            if (val > north) val = north;
            if (val < val_min) val = val_min;
            latMaxSlider.value = val;
            updatePlot();
        });

        lonMinSlider.addEventListener("change", () => {
            let val = parseFloat(lonMinSlider.value);
            let val_max = parseFloat(lonMaxSlider.value);
            if (val < west) val = west;
            if (val > val_max) val = val_max;
            lonMinSlider.value = val;
            updatePlot();
        });

        lonMaxSlider.addEventListener("change", () => {
            let val = parseFloat(lonMaxSlider.value);
            let val_min = parseFloat(lonMinSlider.value);
            if (val > east) val = east;
            if (val < val_min) val = val_min;
            lonMaxSlider.value = val;
            updatePlot();
        });

        console.log("Sliders initialized with MAP_BOUNDS:", MAP_BOUNDS);
    }

    // Expose these for the iframe popup "X" button
    window.getSelectedDatasetValues = getSelectedDatasetValues;
    window.plotData = plotData;

    document.addEventListener("DOMContentLoaded", function () {
        // Hook up UI events
        const downloadBtn = document.getElementById("downloadGeoJSON");
        if (downloadBtn) {
            downloadBtn.addEventListener("click", downloadGeoJSON);
        }

        // Rank filters update BOTH chart and map
        document.getElementById("evidenceRankFilter").addEventListener("change", updatePlot);
        document.getElementById("ageRankFilter").addEventListener("change", updatePlot);
        document.getElementById("siteEvidenceRankFilter").addEventListener("change", updatePlot);

        // Dataset multi-select lives inside datasetContainer
        const datasetContainer = document.getElementById("datasetContainer");
        if (datasetContainer) {
            datasetContainer.addEventListener("change", updatePlot);
        }

        // Chart type change: only re-draw chart
        document.getElementById('xAxisSelector').addEventListener('change', () => {
            const selectedValues = getSelectedDatasetValues();
            plotData(selectedValues);
        });

        // Initialize sliders and initial view
        initializeSliders();

        // Initial chart: all datasets; initial map markers consistent
        const allDatasetValues = Object.keys(GEOJSON_URLS || {});
        plotData(allDatasetValues);
        updateMapMarkers();
    });
</script>
{% endblock %}